
type Query {
    ## Tenants
    getRootTenant: Tenant!
    getTenants: [Tenant!]!
    getTenantById(tenantId: String!): Tenant

    ## Clients
    getClients(tenantId: String): [Client!]!
    getClientById(clientId: String!): Client

    ## Users
    getUsers(tenantId: String): [User!]!
    getUserById(userId: String!): User
    
    ## Keys
    getSigningKeys(tenantId: String): [SigningKey!]!
    getSigningKeyById(signingKeyId: String!): SigningKey

    ## RateLimit
    getRateLimits(tenantId: String): [RateLimit!]!
    getRateLimitById(rateLimitId: String!): RateLimit

    ## Scope
    getScope(tenantId: String): [Scope!]!
    getScopeById(scopeId: String!): Scope

    ## Scope constraints
    getScopeConstraintSchemas: [ScopeConstraintSchema!]!
    getScopeConstraintSchemaById(scopeConstraintSchemaId: String): ScopeConstraintSchema

    ## Access rules
    getAccessRules(tenantId: String): [AccessRule!]!
    getAccessRuleById(accessRuleId: String!): AccessRule

    ## AuthenticationGroups
    getAuthenticationGroups(tenantId: String): [AuthenticationGroup!]!
    getAuthenticationGroupById(authenticationGroupId: String!): AuthenticationGroup

    ## Groups
    getAuthorizationGroups: [AuthorizationGroup!]!
    getAuthorizationGroupById(groupId: String!): AuthorizationGroup
    getUserAuthorizationGroups(userId: String!): [AuthorizationGroup!]!

    ## External OIDC Providers
    getFederatedOIDCProviders(tenantId: String): [FederatedOIDCProvider!]!
    getFederatedOIDCProviderById(federatedOIDCProviderId: String!): FederatedOIDCProvider
    
}

type Mutation {
    ## Tenants
    createRootTenant(tenantInput: TenantCreateInput!): Tenant
    updateRootTenant(tenantInput: TenantUpdateInput!): Tenant
    
    createTenant(tenantInput: TenantCreateInput!): Tenant
    updateTenant(tenantInput: TenantUpdateInput!): Tenant
    deleteTenant(tenantId: String!): String
    addDomainToTenantManagement(tenantId: String!, domain: String!): String
    removeDomainFromTenantManagement(tenantId: String!, domain: String!): String

    ## Clients
    createClient(clientInput: ClientCreateInput!): Client
    updateClient(clientInput: ClientUpdateInput!): Client
    ## Just returns the ID after deletion is complete
    deleteClient(clientId: String!): String

    ## Users

    
    ## Keys
    createSigningKey(keyInput: SigningKeyCreateInput!): SigningKey!
    deleteSigningKey(keyId: String!): String!

    ## RateLimit
    createRateLimit(rateLimitInput: RateLimitCreateInput!): RateLimit
    updateRateLimit(rateLimitInput: RateLimitUpdateInput!): RateLimit
    deleteRateLimit(rateLimitId: String!): String
    assignRateLimitToTenant(tenantId: String!, rateLimitId: String!, allowUnlimited: Boolean, limit: Int, rateLimitPeriodMinutes: Int): TenantRateLimitRel
    updateRateLimitForTenant(tenantId: String!, rateLimitId: String!, allowUnlimited: Boolean, limit: Int, rateLimitPeriodMinutes: Int): TenantRateLimitRel
    removeRateLimitFromTenant(tenantId: String!, rateLimitId: String!): String

    ## Scope
    createScope(scopeInput: ScopeCreateInput!): Scope
    updateScope(scopeInput: ScopeUpdateInput!): Scope
    deleteScope(scopeId: String!): String
    assignScopeToTenant(tenantId: String!, scopeId: String!, accessRuleId: String): TenantScopeRel
    removeScopeFromTenant(tenantId: String!, scopeId: String!): String
    assignScopeToClient(tenantId: String!, clientId: String!, scopeId: String!): ClientTenantScopeRel
    removeScopeFromClient(tenantId: String!, clientId: String!, scopeId: String!): String

    ## Scope constraint schemas
    createScopeConstraintSchema(scopeConstraintSchemaInput: ScopeConstraintSchemaCreateInput!): ScopeConstraintSchema
    updateScopeConstraintSchema(scopeConstraintSchemaInput: ScopeConstraintSchemaUpdateInput!): ScopeConstraintSchema
    deleteScopeConstraingSchema(scopeConstraintSchemaId: String!): String!

    ## Access rules
    createAccessRule(accessRuleInput: AccessRuleCreateInput!): AccessRule
    updateAccessRule(accessRuleInput: AccessRuleUpdateInput!): AccessRule
    deleteAccessRule(accessRuleId: String!): String!

    ## AuthenticationGroups
    createAuthenticationGroup(authenticationGroupInput: AuthenticationGroupCreateInput!): AuthenticationGroup
    updateAuthenticationGroup(authenticationGroupInput: AuthenticationGroupUpdateInput!): AuthenticationGroup
    deleteAuthenticationGroup(authenticationGroupId: String!): String!
    assignAuthenticationGroupToClient(authenticationGroupId: String!, clientId: String!): AuthenticationGroupClientRel
    removeAuthenticationGroupFromClient(authenticationGroupId: String!, clientId: String!): String
    
    ## Groups
    createAuthorizationGroup(groupInput: AuthorizationGroupCreateInput!): AuthorizationGroup
    updateAuthorizationGroup(groupInput: AuthorizationGroupUpdateInput!): AuthorizationGroup
    deleteAuthorizationGroup(groupId: String!): String!
    addUserToAuthorizationGroup(userId: String!, groupId: String!): UserAuthorizationGroupRel
    removeUserFromAuthorizationGroup(userId: String!, groupId: String!): String

    ## External OIDC Providers
    createFederatedOIDCProvider(oidcProviderInput: FederatedOIDCProviderCreateInput!): FederatedOIDCProvider
    updateFederatedOIDCProvider(oidcProviderInput: FederatedOIDCProviderUpdateInput!): FederatedOIDCProvider
    assignFederatedOIDCProviderToTenant(federatedOIDCProviderId: String!, tenantId: String!): FederatedOIDCProviderTenantRel!
    removeFederatedOIDCProviderFromTenant(federatedOIDCProviderId: String!, tenantId: String!): FederatedOIDCProviderTenantRel!
    assignFederatedOIDCProviderToDomain(federatedOIDCProviderId: String!, domain: String!): FederatedOIDCProviderDomainRel!
    removeFederatedOIDCProviderFromDomain(federatedOIDCProviderId: String!, domain: String!): FederatedOIDCProviderDomainRel!
    deleteFederatedOIDCProvider(federatedOIDCProviderId: String!): String!

}


type LoginFailurePolicy {
    loginFailurePolicyType: String!
    loginfailurepolicytypeid: String
    failureThreshold: Int!
    pauseDurationMinutes: Int
    numberOfPauseCyclesBeforeLocking: Int
    initBackoffDurationMinutes: Int
    numberOfBackoffCyclesBeforeLocking: Int
}

########
# 1.    tenantId -           Write once, read only
# 2.    enabled -            true | false
# 3.    allowedScopeValues - ALL of the scopes that are available for the tenant. A subset of these are
#                            available to each of the clients
# 4.    claimsSupported -    Of all of the OIDC claims, which does this tenant support
# 5.    allowUnlimitedRate - true | false. True will override any rate limit set in the rateLimits property

type Tenant {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    claimsSupported: [String!]!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    allowSocialLogin: Boolean!
    allowAnonymousUsers: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    federatedAuthenticationConstraint: String!
    federatedauthenticationconstraintid: String
    markForDelete: Boolean!
    tenantType: String!
    tenanttypeid: String
}


type AnonymousUserConfiguration {
    anonymoususerconfigurationid: String!
    defaultcountrycode: String!
    defaultlangugecode: String!
    tokenttlseconds: Int!
    scopeids: [String]
    groupids: [String]
}

type TenantAnonymousUserConfigurationRel {
    tenantid: String!
    anonymoususerconfigurationid: String!
}


# Does the tenant have certain users with email domains that can
# manage the tenant for themselves?
type TenantManagementDomainRel {
    tenantId: String!
    domain: String!
}

# Either client secret should be defined or usePkce should be set to true
# if no client secret, then client auth type should be NONE
# refreshTokenAllowed - does the external provider allow for refresh tokens? default false 
#
# socialLoginIcon -> social login, in case the login screen wants to display a "Sign in with Google/Facebook/Twitter + <Google/Facebook/Twitter Icon>"
# socialLoginDisplayName -> social login, the name to display 
type FederatedOIDCProvider {
    federatedOIDCProviderId: String!
    federatedOIDCProviderName: String!
    federatedOIDCProviderDescription: String
    federatedOIDCProviderTenantId: String
    federatedOIDCProviderClientId: String!
    federatedOIDCProviderClientSecret: String
    federatedOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    scopes: [String!]!
    usePkce: Boolean!
    clientAuthType: String!
    clientauthtypeid: String
    federatedOIDCProviderType: String!
    federatedoidcprovidertypeid: String
    socialLoginIcon: String
    socialLoginDisplayName: String
}

type FederatedOIDCProviderTenantRel {    
    federatedOIDCProviderId: String!
    tenantId: String!
}

type SocialOIDCProviderTenantRel {
    federatedOIDCProviderId: String!
    tenantId: String!
}

# domain is the primary key (unique) in this relationship.
type FederatedOIDCProviderDomainRel {
    federatedOIDCProviderId: String!
    domain: String!
}


# 1.    tenantId -      Parent tenant (write once, read only)
# 2.    clientId -      GUID
# 3.    clientSecret -  A 256-bit hex-encoded value
# 4.    clientName
# 5.    clientDescription
# 6.    enabled -       true | false
# 7.    redirectUris - List of redirect URIs for authorization
# 8.    oidcEnabled -  Allow SSO for this client
# 9.    pkceEnabled
# 10.   clientType
# 11.   userTokenTTLSeconds default is 60 minutes, configurable up to 12 hours
# 12.   allowUserSelfRegistration default false
# 13.   allowDelegatedAuthentication default false
type Client {
    tenantId: String!
    clientId: String!
    clientSecret: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean
    redirectUris: [String!]
    oidcEnabled: Boolean!
    pkceEnabled: Boolean!
    clientType: String!
    clienttypeid: String
    userTokenTTLSeconds: Int
    clientTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
}


# 1.    domain is just the domain part of the email
type User {
    userId: String!
    federatedOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    countryCode: String
    preferredLanguageCode: String
    twoFactorAuthType: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
}

type UserTenantRel {
    userId: String!
    tenantId: String!
}

type AuthenticationGroup {
    tenantId: String!
    authenticationGroupId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
}

type AuthenticationGroupClientRel {
    clientId: String!
    authenticationGroupId: String!
}

type AuthenticationGroupUserRel {
    authenticationGroupId: String!
    userId: String!
}

# default - for newly registered or created users within the tenant, assign to any group 
# in the tenant that is marked with default
type AuthorizationGroup {
    tenantId: String!
    groupId: String!
    groupName: String!
    default: Boolean!
}

type UserAuthorizationGroupRel {
    userId: String!
    groupId: String!
}

type UserCredential {
    userId: String!
    salt: String!
    hashedPassword: String!
    hashingAlgorithm: String!
    dateCreated: String!    
}

type SigningKey {
    keyId: String!
    tenantId: String!    
    keyType: String!
    keytypeid: String
    keyuse: String!
    privateKeyPkcs8: String!
    password: String
    certificate: String
    publicKey: String
    expiresAtMs: Float!
    status: String!
    statusid: String
}

# Can optionally have a constraint definition tied to this scope.
# Not a requirement, but if one exists, then you MAY, if you choose,
# create an access rule that you can apply to the tenant (and so the 
# client and groups which belong to the tenant) which have this scope.

type Scope {
    scopeId: String!
    scopeName: String!
    scopeDescription: String
}

type ScopeConstraintSchema {
    scopeConstraintSchemaId: String!
    schemaVersion: Int!
    scopeconstraintschemaname: String!
    scopeId: String!
    scopeconstraintschema: String!
}

type AccessRule {
    accessRuleId: String!
    accessrulename: String!
    scopeId: String!
    scopeConstraintSchemaId: String!
    accessRuleDefinition: String!
}

type RateLimitServiceGroup {
    servicegroupid: String!
    servicegroupname: String!
    servicegroupdescription: String    
}

type RateLimitServiceGroupScopeRel {
    servicegroupid: String!
    scopeid: String!
}

type RateLimit {
    ratelimitid: String!
    ratelimitname: String!
    servicegroupid: String!
}

type TenantRateLimitRel {
    tenantId: String!
    rateLimitId: String!
    allowUnlimitedRate: Boolean
    rateLimit: Int
    rateLimitPeriodMinutes: Int
}


# Access rules CAN be applied at the tenant level for any non-Root tenant
# Any client or group will automatically inherit these restrictions.
# Access rule order of precendence:
# 1. Defined on the user, inherits others from group membership, client and tenant
# 2. Defined on the group, inherits others from client and tenant
# 3. Defined on the client, inherits others from tenant
# 4. Defined on the tenant

type TenantScopeRel {
    tenantId: String!
    scopeId: String!
    accessRuleId: String
}

type ClientTenantScopeRel {
    tenantId: String!
    clientId: String!
    scopeId: String!
    accessruleid: String
}


type AuthorizationGroupScopeRel {
    groupId: String!
    tenantId: String!
    scopeId: String!
    accessruleid: String
}

type UserScopeRel {
    userid: String!
    tenantid: String!
    scopeid: String!
    accessruleid: String
}

type PreAuthenticationState {
    token: String!
    state: String
    redirectUri: String!
    codeChallenge: String
    codeChallengeMethod: String
    responseMode: String!
    responseType: String!
    scope: String!
    tenantId: String!
    clientId: String!
    expiresAtMs: Float!
}

type AuthorizationCodeData {
    code: String!
    redirectUri: String!
    clientId: String!
    tenantId: String!
    scope: String!
    codeChallengeMethod: String
    codeChallenge: String
    userId: String!
    expiresAtMs: Float!
}

type RefreshData {
    refreshToken: String!
    tenantId: String!
    clientId: String!
    userId: String!
    redirecturi: String!
    refreshTokenClientType: String!
    refreshtokenclienttypeid: String
    refreshCount: Int!
    scope: String!
}

type FederatedOIDCAuthorizationRel {
    state: String!
    codeVerifier: String
    codechallengemethod: String
    federatedOIDCProviderId: String!
    initState: String!
    initRedirectUri: String!
    initTenantId: String!
    initClientId: String!
    initScope: String!
    initCodeChallengeMethod: String
    initCodeChallenge: String
    initResponseMode: String!
    initResponseType: String!
    expiresAtMs: Float!
}

type ClientAuthHistory {
    jti: String!
    clientId: String!
    tenantId: String!
    expiresAtSeconds: Float!
}

type Contact {
    objectid: String!
    objecttype: String!
    email: String!
    name: String!
    userid: String
}

type ChangeEventData {
    changeeventid: String!
    objecttype: String!
    objectid: String!
    data: String!
}

type ChangeEvent {
    changeEventId: String!
    changeEventType: String!
    changeEventTypeId: String
    changeEventClass: String!
    changeEventClassId: String
    changeTimestamp: Float!
    changedById: String!
    signature: String!
	keyId: String!
}

type TenantLookAndFeel {
    tenantid: String!
    adminheaderbackgroundcolor: String
    adminheadertextcolor: String
    adminlogo: String
    adminheadertext: String
    authenticationheaderbackgroundcolor: String
    authenticationheadertextcolor: String
    authenticationlogo: String
    authenticationheadertext: String
    footerlinks: [FooterLink]
}

type FooterLink {
    footerlinkid: String!
    tenantid: String!
    linktext: String!
    uri: String!
}

############################################################################
################ INPUT TYPES AND RESPONSES FOR MUTATATIONS #################
############################################################################

input FederatedOIDCProviderCreateInput {
    federatedOIDCProviderId: String!
    federatedOIDCProviderName: String!
    federatedOIDCProviderDescription: String
    federatedOIDCProviderTenantId: String
    federatedOIDCProviderClientId: String!
    federatedOIDCProviderClientSecret: String
    federatedOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    usePkce: Boolean!
    federatedOIDCProviderType: String!
    federatedoidcprovidertypeid: String
    clientAuthType: String!
    clientauthtypeid: String
}

input FederatedOIDCProviderUpdateInput {
    federatedOIDCProviderId: String!
    federatedOIDCProviderName: String!
    federatedOIDCProviderDescription: String
    federatedOIDCProviderTenantId: String
    federatedOIDCProviderClientId: String!
    federatedOIDCProviderClientSecret: String
    federatedOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    usePkce: Boolean!
    federatedOIDCProviderType: String!
    federatedoidcprovidertypeid: String
    clientAuthType: String!
    clientauthtypeid: String
}

input TenantCreateInput {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    claimsSupported: [String!]!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    allowSocialLogin: Boolean!
    federatedAuthenticationConstraint: String!
    federatedOIDCProviderId: String
    tenantType: String!
    contactemaillist: [String!]!
}

input TenantUpdateInput {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    claimsSupported: [String!]!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    allowSocialLogin: Boolean!
    federatedAuthenticationConstraint: String!
    federatedOIDCProviderId: String
    markForDelete: Boolean!
    tenantType: String!
    contactemaillist: [String!]!
}

input ClientCreateInput {
    tenantId: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean
    redirectUris: [String!]
    oidcEnabled: Boolean
    pkceEnabled: Boolean
    clientType: String!
    clienttypeid: String
    userTokenTTLSeconds: Int
    clientTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
    contactemaillist: [String!]!
}

input ClientUpdateInput {
    tenantId: String!
    clientId: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean
    redirectUris: [String!]
    oidcEnabled: Boolean
    pkceEnabled: Boolean
    clientType: String!
    clienttypeid: String
    userTokenTTLSeconds: Int
    clientTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
    contactemaillist: [String!]!
}

input SigningKeyCreateInput {
    tenantId: String!    
    keyType: String!
    keytypeid: String
    use: String!
    privateKey: String!
    password: String
    certificate: String!
}


input RateLimitCreateInput {
    rateLimitDomain: String!
    rateLimitDescription: String
}

input RateLimitUpdateInput {
    rateLimitId: String!
    rateLimitDomain: String!
    rateLimitDescription: String
}
input ScopeCreateInput {
    scopeName: String!
    scopeDescription: String
    scopeConstraintSchemaId: String
}

input ScopeUpdateInput {
    scopeId: String!
    scopeName: String!
    scopeDescription: String
    scopeConstraintSchemaId: String
}

input AuthenticationGroupCreateInput {
    tenantId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
}

input AuthenticationGroupUpdateInput {
    tenantId: String!
    authenticationGroupId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
}

input AuthorizationGroupCreateInput {
    tenantId: String!
    groupName: String!
    default: Boolean!
}

input AuthorizationGroupUpdateInput {
    tenantId: String!
    groupId: String!
    groupName: String!
    default: Boolean!
}

## Scope constraint schemas
input ScopeConstraintSchemaCreateInput {
    scopeId: String!
    schema: String!
}

input ScopeConstraintSchemaUpdateInput {
    scopeConstraintSchemaId: String!
    scopeId: String!
    schema: String!
}

## Access rules
input AccessRuleCreateInput {
    scopeId: String!
    scopeConstraintSchemaId: String!
    accessRuleDefinition: String!
}

input AccessRuleUpdateInput {
    accessRuleId: String!
    scopeId: String!
    scopeConstraintSchemaId: String!
    accessRuleDefinition: String!
}

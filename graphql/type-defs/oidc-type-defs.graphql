
type Query {


    ## Search
    search(searchInput: SearchInput!): ObjectSearchResults!
    lookahead(term: String!): [LookaheadResult!]!
    relSearch(relSearchInput: RelSearchInput!): RelSearchResults!


    ## Tenants
    getRootTenant: Tenant!
    getTenants(tenantIds: [String!], federatedOIDCProviderId: String, scopeId: String): [Tenant!]!
    getTenantById(tenantId: String!): Tenant
    getTenantMetaData(tenantId: String!): TenantMetaData
    getDomainsForTenantManagement(tenantId: String!): [TenantManagementDomainRel!]!
    getDomainsForTenantAuthentication(tenantId: String!): [TenantRestrictedAuthenticationDomainRel!]!
    getAnonymousUserConfiguration(tenantId: String!): TenantAnonymousUserConfiguration
    getLegacyUserMigrationConfiguration(tenantId: String!): TenantLegacyUserMigrationConfig
    getTenantLookAndFeel(tenantId: String!): TenantLookAndFeel
    getTenantPasswordConfig(tenantId: String!): TenantPasswordConfig
    getTenantLoginFailurePolicy(tenantId: String!): TenantLoginFailurePolicy

    ## Clients
    getClients(tenantId: String): [Client!]!
    getClientById(clientId: String!): Client
    getRedirectURIs(clientId: String!): [String!]!

    ## Users
    getUsers(tenantId: String): [User!]!
    getUserById(userId: String!): User
    getUserTenantRels(userId: String!): [UserTenantRelView!]!
    getUserMFARels(userId: String!): [UserMFARel!]!
    getUserSessions(userId: String!): [UserSession!]!

    ## For tenant management and access
    me: PortalUserProfile
    
    ## Keys
    getSigningKeys(tenantId: String): [SigningKey!]!
    getSigningKeyById(signingKeyId: String!): SigningKey

    ## RateLimit
    getRateLimitServiceGroups(tenantId: String): [RateLimitServiceGroup!]!
    getRateLimitServiceGroupById(serviceGroupId: String!): RateLimitServiceGroup
    getRateLimitTenantRels(tenantId: String, rateLimitServiceGroupId: String): [TenantRateLimitRel!]!
    getRateLimitTenantRelViews(rateLimitServiceGroupId: String, tenantId: String): [TenantRateLimitRelView!]!

    ## Scope
    getScope(tenantId: String!, filterBy: ScopeFilterCriteria!): [Scope!]!
    getScopeById(scopeId: String!): Scope
    getClientScopes(clientId: String!): [Scope!]!
    getAuthorizationGroupScopes(groupId: String!): [Scope!]!
    getUserScopes(userId: String!, tenantId: String!): [Scope!]!


    ## Scope constraints
    getScopeAccessRuleSchemas: [ScopeAccessRuleSchema!]!
    getScopeAccessRuleSchemaById(scopeAccessRuleSchemaId: String): ScopeAccessRuleSchema

    ## Access rules
    getAccessRules(tenantId: String): [AccessRule!]!
    getAccessRuleById(accessRuleId: String!): AccessRule

    ## AuthenticationGroups
    getAuthenticationGroups(tenantId: String, clientId: String, userId: String): [AuthenticationGroup!]!
    getAuthenticationGroupById(authenticationGroupId: String!): AuthenticationGroup

    ## Groups
    getAuthorizationGroups(tenantId: String): [AuthorizationGroup!]!
    getAuthorizationGroupById(groupId: String!): AuthorizationGroup
    getUserAuthorizationGroups(userId: String!): [AuthorizationGroup!]!

    ## External OIDC Providers
    getFederatedOIDCProviders(tenantId: String): [FederatedOIDCProvider!]!
    getFederatedOIDCProviderById(federatedOIDCProviderId: String!): FederatedOIDCProvider
    getFederatedOIDCProviderDomainRels(federatedOIDCProviderId: String, domain: String): [FederatedOIDCProviderDomainRel!]!

    
    ## Change events
    getChangeEvents(objectId: String!): [ChangeEvent!]!

    ## Scheduler
    getSchedulerLocks: [SchedulerLock]

    ## Contacts
    getContacts(objectId: String!): [Contact!]!

    ## Viewing secrets or private keys
    getSecretValue(objectId: String!, objectType: SecretObjectType!): String

    ## Mark for deletion
    getMarkForDeleteById(markForDeleteId: String!): MarkForDelete
    getDeletionStatus(markForDeleteId: String!): [DeletionStatus!]!

    ## i18n
    getStateProvinceRegions(countryCode: String!): [StateProvinceRegion!]!

    ## Captcha
    getCaptchaConfig: CaptchaConfig

    ## System settings
    getSystemSettings: SystemSettings!
    getRunningJobs: JobData!


}

type Mutation {
    ## Tenants
    createRootTenant(tenantInput: TenantCreateInput!): Tenant
    updateRootTenant(tenantInput: TenantUpdateInput!): Tenant
    
    createTenant(tenantInput: TenantCreateInput!): Tenant
    updateTenant(tenantInput: TenantUpdateInput!): Tenant
    addDomainToTenantManagement(tenantId: String!, domain: String!): TenantManagementDomainRel
    removeDomainFromTenantManagement(tenantId: String!, domain: String!): String
    addDomainToTenantRestrictedAuthentication(tenantId: String!, domain: String!): TenantRestrictedAuthenticationDomainRel
    removeDomainFromTenantRestrictedAuthentication(tenantId: String!, domain: String!): String
    setTenantPasswordConfig(passwordConfigInput: PasswordConfigInput!): TenantPasswordConfig
    removeTenantPasswordConfig(tenantId: String!): String
    setTenantLegacyUserMigrationConfig(tenantLegacyUserMigrationConfigInput: TenantLegacyUserMigrationConfigInput!): TenantLegacyUserMigrationConfig
    removeTenantLegacyUserMigrationConfig(tenantId: String!): String
    setTenantAnonymousUserConfig(tenantAnonymousUserConfigInput: TenantAnonymousUserConfigInput!): TenantAnonymousUserConfiguration
    removeTenantAnonymousUserConfig(tenantId: String!): String
    setTenantLookAndFeel(tenantLookAndFeelInput: TenantLookAndFeelInput!): TenantLookAndFeel    
    removeTenantLookAndFeel(tenantId: String!): String
    setTenantLoginFailurePolicy(tenantLoginFailurePolicyInput: TenantLoginFailurePolicyInput!): TenantLoginFailurePolicy!
    removeTenantLoginFailurePolicy(tenantId: String!): String!
    
    ## Clients
    createClient(clientInput: ClientCreateInput!): Client
    updateClient(clientInput: ClientUpdateInput!): Client
    addRedirectURI(clientId: String!, uri: String!): String
    removeRedirectURI(clientId: String!, uri: String!): String
    assignAuthenticationGroupToClient(authenticationGroupId: String!, clientId: String!): AuthenticationGroupClientRel
    removeAuthenticationGroupFromClient(authenticationGroupId: String!, clientId: String!): String

    ## Users
    createUser(tenantId: String!, userInput: UserCreateInput!): User!    
    updateUser(userInput: UserUpdateInput!): User!
    updateUserTenantRel(tenantId: String!, userId: String!, relType: String!): UserTenantRel!
    assignUserToTenant(tenantId: String!, userId: String!, relType: String!): UserTenantRel!
    removeUserFromTenant(tenantId: String!, userId: String!): String
    deleteUserSession(userId: String!, clientId: String!, tenantId: String!): String
    rotatePassword(userId: String!, oldPassword: String!, newPassword: String!): Boolean
    unlockUser(userId: String!): Boolean
    

    ## Authentication Flows
    authenticateHandleUserCodeInput(userCode: String!): UserAuthenticationStateResponse!
    authenticateHandleUserNameInput(username: String!, tenantId: String, preAuthToken: String, returnToUri: String, deviceCodeId: String): UserAuthenticationStateResponse!    
    authenticateUser(username: String!, password: String!, tenantId: String!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    authenticateUserAndMigrate(username: String!, password: String!, tenantId: String!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    authenticateHandleForgotPassword(authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    authenticateRotatePassword(userId: String!, newPassword: String!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    authenticateConfigureTOTP(userId: String!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    authenticateValidateTOTP(userId: String!, totpTokenValue: String!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    authenticateRegisterSecurityKey(userId: String!, fido2KeyRegistrationInput: Fido2KeyRegistrationInput!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    authenticateValidateSecurityKey(userId: String!, fido2KeyAuthenticationInput: Fido2KeyAuthenticationInput!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    authenticateValidatePasswordResetToken(token: String!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    authenticateAcceptTermsAndConditions(accepted: Boolean!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!
    cancelAuthentication(userId: String!, authenticationSessionToken: String!, preAuthToken: String): UserAuthenticationStateResponse!


    ## Social OIDC Authentication Flow
    authenticateWithSocialOIDCProvider(preAuthToken: String, tenantId: String!, federatedOIDCProviderId: String!): UserAuthenticationStateResponse!

    ## Registration Flows
    registerUser(tenantId: String!, userInput: UserCreateInput!, preAuthToken: String, deviceCodeId: String): UserRegistrationStateResponse!
    registerVerifyEmailAddress(userId: String!, token: String!, registrationSessionToken: String!, preAuthToken: String): UserRegistrationStateResponse!
    registerConfigureTOTP(userId: String!, registrationSessionToken: String!, preAuthToken: String, skip: Boolean!): UserRegistrationStateResponse!
    registerValidateTOTP(userId: String!, registrationSessionToken: String!, totpTokenValue: String!, preAuthToken: String): UserRegistrationStateResponse!
    registerConfigureSecurityKey(userId: String!, registrationSessionToken: String!, fido2KeyRegistrationInput: Fido2KeyRegistrationInput, preAuthToken: String, skip: Boolean!): UserRegistrationStateResponse!
    registerValidateSecurityKey(userId: String!, registrationSessionToken: String!, fido2KeyAuthenticationInput: Fido2KeyAuthenticationInput!, preAuthToken: String): UserRegistrationStateResponse!
    registerAddBackupEmail(userId: String!, backupEmail: String, registrationSessionToken: String!, preAuthToken: String, skip: Boolean!): UserRegistrationStateResponse!
    registerVerifyBackupEmail(userId: String!, token: String!, registrationSessionToken: String!, preAuthToken: String): UserRegistrationStateResponse!
    registerAddDuressPassword(userId: String!, password: String, skip: Boolean!, registrationSessionToken: String!, preAuthToken: String): UserRegistrationStateResponse!
    cancelRegistration(userId: String!, registrationSessionToken: String!, preAuthToken: String, deviceCodeId: String): UserRegistrationStateResponse!

    ## MFA Utilities
    generateTOTP(userId: String!): TOTPResponse!
    validateTOTP(userId: String!, totpToken: String!): Boolean!
    deleteTOTP(userId: String!): String
    deleteFIDOKey(userId: String!): String
    createFido2RegistrationChallenge(userId: String!, sessionToken: String, sessionTokenType: String): Fido2RegistrationChallengeResponse
    createFido2AuthenticationChallenge(userId: String!, sessionToken: String, sessionTokenType: String): Fido2AuthenticationChallengeResponse

    
    ## Keys
    autoCreateSigningKey(keyInput: AutoCreateSigningKeyInput!): SigningKey!
    createSigningKey(keyInput: SigningKeyCreateInput!): SigningKey!
    updateSigningKey(keyInput: SigningKeyUpdateInput!): SigningKey!

    ## RateLimit
    createRateLimitServiceGroup(rateLimitServiceGroupInput: RateLimitServiceGroupCreateInput!): RateLimitServiceGroup
    updateRateLimitServiceGroup(rateLimitServiceGroupInput: RateLimitServiceGroupUpdateInput!): RateLimitServiceGroup
    assignRateLimitToTenant(tenantId: String!, serviceGroupId: String!, allowUnlimited: Boolean, limit: Int, rateLimitPeriodMinutes: Int): TenantRateLimitRel
    updateRateLimitForTenant(tenantId: String!, serviceGroupId: String!, allowUnlimited: Boolean, limit: Int, rateLimitPeriodMinutes: Int): TenantRateLimitRel
    removeRateLimitFromTenant(tenantId: String!, serviceGroupId: String!): String

    ## Scope
    createScope(scopeInput: ScopeCreateInput!): Scope
    updateScope(scopeInput: ScopeUpdateInput!): Scope
    assignScopeToTenant(tenantId: String!, scopeId: String!, accessRuleId: String): TenantAvailableScope
    bulkAssignScopeToTenant(tenantId: String!, bulkScopeInput: [BulkScopeInput!]!): [TenantAvailableScope!]!
    removeScopeFromTenant(tenantId: String!, scopeId: String!): String
    assignScopeToClient(clientId: String!, tenantId: String!, scopeId: String!): ClientScopeRel
    bulkAssignScopeToClient(clientId: String!, tenantId: String!, bulkScopeInput: [BulkScopeInput!]!): [ClientScopeRel!]!
    removeScopeFromClient(clientId: String!, tenantId: String!, scopeId: String!): String
    assignScopeToAuthorizationGroup(groupId: String!, scopeId: String!, tenantId: String!): AuthorizationGroupScopeRel
    bulkAssignScopeToAuthorizationGroup(groupId: String!, tenantId: String!, bulkScopeInput: [BulkScopeInput!]!): [AuthorizationGroupScopeRel!]!
    removeScopeFromAuthorizationGroup(groupId: String!, scopeId: String!, tenantId: String!): String
    assignScopeToUser(userId: String!, tenantId: String!, scopeId: String!): UserScopeRel
    bulkAssignScopeToUser(userId: String!, tenantId: String!, bulkScopeInput: [BulkScopeInput!]!): [UserScopeRel!]!
    removeScopeFromUser(userId: String!, tenantId: String!, scopeId: String!): String

    ## Scope constraint schemas
    createScopeAccessRuleSchema(scopeAccessRuleSchemaInput: ScopeAccessRuleSchemaCreateInput!): ScopeAccessRuleSchema
    updateScopeAccessRuleSchema(scopeAccessRuleSchemaInput: ScopeAccessRuleSchemaUpdateInput!): ScopeAccessRuleSchema
    deleteScopeAccessRuleSchema(scopeAccessRuleSchemaId: String!): String!

    ## Access rules
    createAccessRule(accessRuleInput: AccessRuleCreateInput!): AccessRule
    updateAccessRule(accessRuleInput: AccessRuleUpdateInput!): AccessRule
    deleteAccessRule(accessRuleId: String!): String!

    ## AuthenticationGroups
    createAuthenticationGroup(authenticationGroupInput: AuthenticationGroupCreateInput!): AuthenticationGroup
    updateAuthenticationGroup(authenticationGroupInput: AuthenticationGroupUpdateInput!): AuthenticationGroup
    addUserToAuthenticationGroup(authenticationGroupId: String!, userId: String!): AuthenticationGroupUserRel
    removeUserFromAuthenticationGroup(authenticationGroupId: String!, userId: String!): String
    
    ## Groups
    createAuthorizationGroup(groupInput: AuthorizationGroupCreateInput!): AuthorizationGroup
    updateAuthorizationGroup(groupInput: AuthorizationGroupUpdateInput!): AuthorizationGroup
    addUserToAuthorizationGroup(userId: String!, groupId: String!): AuthorizationGroupUserRel
    removeUserFromAuthorizationGroup(userId: String!, groupId: String!): String

    ## External OIDC Providers
    createFederatedOIDCProvider(oidcProviderInput: FederatedOIDCProviderCreateInput!): FederatedOIDCProvider
    updateFederatedOIDCProvider(oidcProviderInput: FederatedOIDCProviderUpdateInput!): FederatedOIDCProvider
    assignFederatedOIDCProviderToTenant(federatedOIDCProviderId: String!, tenantId: String!): FederatedOIDCProviderTenantRel!
    removeFederatedOIDCProviderFromTenant(federatedOIDCProviderId: String!, tenantId: String!): FederatedOIDCProviderTenantRel!
    assignFederatedOIDCProviderToDomain(federatedOIDCProviderId: String!, domain: String!): FederatedOIDCProviderDomainRel!
    removeFederatedOIDCProviderFromDomain(federatedOIDCProviderId: String!, domain: String!): FederatedOIDCProviderDomainRel!

    ## Scheduler locks
    deleteSchedulerLock(instanceId: String!): String!

    ## Contacts
    addContact(contactCreateInput: ContactCreateInput!): Contact!
    removeContact(contactId: String!): String!

    ## Mark for deletion
    markForDelete(markForDeleteInput: MarkForDeleteInput!): MarkForDelete

    ## Captcha
    setCaptchaConfig(captchaConfigInput: CaptchaConfigInput!): CaptchaConfig!
    removeCaptchaConfig: String!

    ## System settings
    updateSystemSettings(systemSettingsUpdateInput: SystemSettingsUpdateInput!): SystemSettings!

    ## Secret sharing and entry
    generateSecretShareLink(objectId: String!, secretShareObjectType: SecretShareObjectType!, email: String!): Boolean!
    enterSecretValue(otp: String!, secretValue: String!): Boolean!

}

enum ScopeFilterCriteria {
    EXISTING
    AVAILABLE
}

enum SecretObjectType {
    CLIENT_SECRET
    PRIVATE_KEY
    PRIVATE_KEY_PASSWORD
    OIDC_PROVIDER_CLIENT_SECRET
}

type TenantLoginFailurePolicy {
    tenantId: String!
    loginFailurePolicyType: String!
    failureThreshold: Int!
    pauseDurationMinutes: Int
    maximumLoginFailures: Int
}


type Tenant {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!    
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    allowSocialLogin: Boolean!
    allowAnonymousUsers: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    federatedAuthenticationConstraint: String!
    federatedauthenticationconstraintid: String
    markForDelete: Boolean!
    tenantType: String!
    tenanttypeid: String
    migrateLegacyUsers: Boolean!
    allowLoginByPhoneNumber: Boolean!
    allowForgotPassword: Boolean!
    defaultRateLimit: Int
    defaultRateLimitPeriodMinutes: Int
    registrationRequireTermsAndConditions: Boolean!
    termsAndConditionsUri: String
    registrationRequireCaptcha: Boolean!
}

type TenantSupportedClaimRel {
    tenantId: String!
    claim: String!
}

type TenantAnonymousUserConfiguration {
    tenantId: String!
    defaultcountrycode: String
    defaultlangugecode: String
    tokenttlseconds: Int!
}


# Does the tenant have certain users with email domains that can
# manage the tenant for themselves?
type TenantManagementDomainRel {
    tenantId: String!
    domain: String!
}

# Does the tenant have certain users who are allowed to login
# using this tenant?
type TenantRestrictedAuthenticationDomainRel {
    tenantId: String!
    domain: String!
}

type FederatedOIDCProvider {
    federatedOIDCProviderId: String!
    federatedOIDCProviderName: String!
    federatedOIDCProviderDescription: String
    federatedOIDCProviderTenantId: String
    federatedOIDCProviderClientId: String!
    federatedOIDCProviderClientSecret: String
    federatedOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    scopes: [String!]!
    usePkce: Boolean!
    clientAuthType: String!
    clientauthtypeid: String
    federatedOIDCProviderType: String!
    federatedoidcprovidertypeid: String
    socialLoginProvider: String
    markForDelete: Boolean!
}

type FederatedOIDCProviderTenantRel {    
    federatedOIDCProviderId: String!
    tenantId: String!
}

type CaptchaConfig {
    alias: String!
    projectId: String
    siteKey: String!
    apiKey: String!
    minScopeThreshold: Float
    useCaptchaV3: Boolean!
}

# domain is the primary key (unique) in this relationship.
type FederatedOIDCProviderDomainRel {
    federatedOIDCProviderId: String!
    domain: String!
}

type TenantPasswordConfig {
    tenantId: String!
    passwordMinLength: Int!
    passwordMaxLength: Int! 
    passwordHashingAlgorithm: String!
    requireUpperCase: Boolean!
	requireLowerCase: Boolean!
	requireNumbers: Boolean!
	requireSpecialCharacters: Boolean!
	specialCharactersAllowed: String
    requireMfa: Boolean!
    mfaTypesRequired: String
    maxRepeatingCharacterLength: Int
    passwordRotationPeriodDays: Int
    passwordHistoryPeriod: Int
}


type TenantLegacyUserMigrationConfig {
    tenantId: String!
    authenticationUri: String!
    userProfileUri: String!
    usernameCheckUri: String!
}

type Client {
    tenantId: String!
    clientId: String!
    clientSecret: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean!
    oidcEnabled: Boolean!
    pkceEnabled: Boolean!
    clientType: String!
    clienttypeid: String
    userTokenTTLSeconds: Int
    clientTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
    markForDelete: Boolean!
}


type PortalUserProfile {
    userId: String!
    federatedOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    countryCode: String
    preferredLanguageCode: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
    scope: [Scope!]!
    tenantId: String!
    tenantName: String!
    managementAccessTenantId: String
}

type UserProfileAuthorizationGroup {
    groupId: String!
    groupName: String!
}

type OIDCUserProfile {
    userId: String!
    federatedOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    countryCode: String
    preferredLanguageCode: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
    scope: [Scope!]!
    tenantId: String!
    tenantName: String!
    clientId: String!
    clientName: String!
    expiresAtMs: Float!
    authorizationGroups: [UserProfileAuthorizationGroup!]!
}

# 1.    domain is just the domain part of the email
type User {
    userId: String!
    federatedOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    addressLine1: String
    city: String
    postalCode: String
    stateRegionProvince: String
    countryCode: String
    preferredLanguageCode: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
    markForDelete: Boolean!
}

type UserTermsAndConditionsAccepted {
    userId: String!
    tenantId: String!
    acceptedAtMs: Float!
}

type UserTenantRel {
    userId: String!
    tenantId: String!
    enabled: Boolean!
    relType: String!
}

type UserTenantRelView {
    userId: String!
    tenantId: String!
    tenantName: String!
    relType: String!
}

type AuthenticationGroup {
    tenantId: String!
    authenticationGroupId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
    defaultGroup: Boolean!
    markForDelete: Boolean!
}

type AuthenticationGroupClientRel {
    clientId: String!
    authenticationGroupId: String!
}

type AuthenticationGroupUserRel {
    authenticationGroupId: String!
    userId: String!
}

# default - for newly registered or created users within the tenant, assign to any group 
# in the tenant that is marked with default
type AuthorizationGroup {
    tenantId: String!
    groupId: String!
    groupName: String!
    groupDescription: String
    default: Boolean!
    allowForAnonymousUsers: Boolean!
    markForDelete: Boolean!
}

type AuthorizationGroupUserRel {
    userId: String!
    groupId: String!
}


type UserCredential {
    userId: String!
    salt: String!
    hashedPassword: String!
    hashingAlgorithm: String!
    dateCreated: String!    
}

type SigningKey {
    keyId: String!
    tenantId: String!    
    keyType: String!
    keyName: String!
    keyTypeId: String
    keyUse: String!
    privateKeyPkcs8: String!
    password: String
    certificate: String
    publicKey: String
    expiresAtMs: Float!
    createdAtMs: Float!
    status: String!
    statusId: String
    markForDelete: Boolean!
}

# Can optionally have a constraint definition tied to this scope.
# Not a requirement, but if one exists, then you MAY, if you choose,
# create an access rule that you can apply to the tenant (and so the 
# client and groups which belong to the tenant) which have this scope.

type Scope {
    scopeId: String!
    scopeName: String!
    scopeDescription: String!
    scopeUse: String!
    markForDelete: Boolean!
}

type ScopeAccessRuleSchema {
    scopeAccessRuleSchemaId: String!
    schemaVersion: Int!
    scopeId: String!
    scopeAccessRuleSchema: String!
}

type AccessRule {
    accessRuleId: String!
    accessRuleName: String!
    scopeAccessRuleSchemaId: String!
    accessRuleDefinition: String!
}

type RateLimitServiceGroup {
    servicegroupid: String!
    servicegroupname: String!
    servicegroupdescription: String
    markForDelete: Boolean!
}


type RateLimit {
    ratelimitid: String!
    ratelimitname: String!
    servicegroupid: String!
}

type TenantRateLimitRel {
    tenantId: String!
    servicegroupid: String!
    allowUnlimitedRate: Boolean
    rateLimit: Int
    rateLimitPeriodMinutes: Int
}

type TenantRateLimitRelView {
    tenantId: String!
    tenantName: String!
    servicegroupid: String!
    servicegroupname: String!
    allowUnlimitedRate: Boolean
    rateLimit: Int
    rateLimitPeriodMinutes: Int
}


# Access rules CAN be applied at the tenant level for any non-Root tenant
# Any client or group will automatically inherit these restrictions.
# Access rule order of precendence:
# 1. Defined on the user, inherits others from group membership, client and tenant
# 2. Defined on the group, inherits others from client and tenant
# 3. Defined on the client, inherits others from tenant
# 4. Defined on the tenant

type TenantAvailableScope {
    tenantId: String!
    scopeId: String!
    accessRuleId: String
}

type ClientScopeRel {
    tenantId: String!
    clientId: String!
    scopeId: String!
}


type AuthorizationGroupScopeRel {
    groupId: String!
    tenantId: String!
    scopeId: String!
}

type UserScopeRel {
    userId: String!
    tenantId: String!
    scopeId: String!
}

type PreAuthenticationState {
    token: String!
    state: String
    redirectUri: String!
    codeChallenge: String
    codeChallengeMethod: String
    responseMode: String!
    responseType: String!
    scope: String!
    tenantId: String!
    clientId: String!
    expiresAtMs: Float!
}

type AuthorizationCodeData {
    code: String!
    redirectUri: String!
    clientId: String!
    tenantId: String!
    scope: String!
    codeChallengeMethod: String
    codeChallenge: String
    userId: String!
    expiresAtMs: Float!
}

enum DeviceCodeAuthorizationStatus {
    PENDING
    CANCELLED
    APPROVED
}

type AuthorizationDeviceCodeData {
    deviceCodeId: String!
    deviceCode: String!
    userCode: String!
    clientId: String!
    tenantId: String!
    scope: String!    
    expiresAtMs: Float!
    authorizationStatus: DeviceCodeAuthorizationStatus!
    userId: String
}

type AuthorizationReturnUri {
    uri: String!
    code: String!
    state: String
}

type SuccessfulLoginResponse {
    mfaEnabled: Boolean!
    userId: String!
    mfaType: String
    challenge: String
}

type UserSession {
    tenantId: String!
    clientId: String!
    userId: String!
    tenantName: String!
    clientName: String!
}

type RefreshData {
    refreshToken: String!
    tenantId: String!
    clientId: String!
    userId: String!
    redirecturi: String!
    refreshTokenClientType: String!
    codeChallenge: String
    codeChallengeMethod: String
    refreshCount: Int!
    scope: String!
    expiresAtMs: Float!
}

enum FederatedOIDCAuthorizationRelType {
    AUTHORIZATION_REL_TYPE_PORTAL_AUTH
    AUTHORIZATION_REL_TYPE_CLIENT_AUTH
}

type FederatedOIDCAuthorizationRel {
    federatedOIDCAuthorizationRelType: FederatedOIDCAuthorizationRelType!
    email: String
    userId: String
    state: String!
    codeVerifier: String
    codechallengemethod: String
    federatedOIDCProviderId: String!
    initState: String!
    initRedirectUri: String!
    initTenantId: String!
    initClientId: String
    initScope: String!
    initCodeChallengeMethod: String
    initCodeChallenge: String
    initResponseMode: String!
    initResponseType: String!
    expiresAtMs: Float!
    returnUri: String
}

type ClientAuthHistory {
    jti: String!
    clientId: String!
    tenantId: String!
    expiresAtSeconds: Float!
}

type Contact {
    contactid: String!
    objectid: String!
    objecttype: String!
    email: String!
    name: String
    userid: String
}

type ChangeEvent {
    changeEventId: String!
    objectid: String!
    objecttype: String!
    changeEventType: String!
    changeEventTypeId: String
    changeEventClass: String!
    changeEventClassId: String
    changeTimestamp: Float!
    changedBy: String!
    data: String!
}

type TenantLookAndFeel {
    tenantid: String!
    adminheaderbackgroundcolor: String
    adminheadertextcolor: String
    adminlogo: String
    adminheadertext: String
    authenticationheaderbackgroundcolor: String
    authenticationheadertextcolor: String
    authenticationlogo: String
    authenticationlogomimetype: String
    authenticationheadertext: String
    footerlinks: [FooterLink]
}

type FooterLink {
    footerlinkid: String!
    tenantid: String!
    linktext: String!
    uri: String!
}

type TenantMetaData {
    tenantLookAndFeel: TenantLookAndFeel
    tenant: Tenant!
    systemSettings: SystemSettings!
}

type SchedulerLock {
    lockName: String!
    lockInstanceId: String!
    lockStartTimeMS: Float!
    lockExpiresAtMS: Float!
}

type UserFailedLogin {
    userId: String!
    failureAtMs: Float!
    nextLoginNotBefore: Float!
    failureCount: Float!
}


type TenantSelectorData {
    tenantId: String!
    tenantName: String!
}

enum AuthenticationState {
    AUTH_WITH_FEDERATED_OIDC
    SELECT_TENANT
    REGISTER
    SELECT_TENANT_THEN_REGISTER
    ENTER_PASSWORD
    ROTATE_PASSWORD
    VALIDATE_PASSWORD_RESET_TOKEN
    CONFIGURE_TOTP
    VALIDATE_TOTP
    CONFIGURE_SECURITY_KEY
    VALIDATE_SECURITY_KEY
    REDIRECT_BACK_TO_APPLICATION
    REDIRECT_TO_IAM_PORTAL
    COMPLETED
    EXPIRED
    CANCELLED
    ERROR
    ACCEPT_TERMS_AND_CONDITIONS
    ENTER_PASSWORD_AND_MIGRATE_USER
    POST_AUTHN_STATE_SEND_SECURITY_EVENT_SUCCESS_LOGON
    POST_AUTHN_STATE_SEND_SECURITY_EVENT_DURESS_LOGON
    POST_AUTHN_STATE_SEND_SECURITY_EVENT_DEVICE_REGISTERED
    ENTER_EMAIL
    ENTER_USER_CODE
}

type AuthenticationError {
    errorCode: String!
    errorMessage: String!
}

type UserAuthenticationStateResponse {
    userAuthenticationState: UserAuthenticationState!
    authenticationError: AuthenticationError!
    availableTenants: [TenantSelectorData!]
    uri: String
    totpSecret: String
    accessToken: String
    tokenExpiresAtMs: Float
    passwordConfig: TenantPasswordConfig
}

type UserAuthenticationState {
	userId: String!
    authenticationSessionToken: String!
    tenantId: String!
	authenticationState: AuthenticationState!
    authenticationStateOrder: Int!
    authenticationStateStatus: String!
    preAuthToken: String
	expiresAtMs: Float!    
    returnToUri: String
    deviceCodeId: String
}


enum RegistrationState {
    VALIDATE_EMAIL
    CONFIGURE_TOTP_REQUIRED
    CONFIGURE_TOTP_OPTIONAL
    VALIDATE_TOTP
    CONFIGURE_SECURITY_KEY_REQUIRED
    CONFIGURE_SECURITY_KEY_OPTIONAL
    VALIDATE_SECURITY_KEY
    COMPLETED
    REDIRECT_BACK_TO_APPLICATION
    REDIRECT_TO_IAM_PORTAL
    EXPIRED
    CANCELLED
    ERROR
    ADD_BACKUP_EMAIL_OPTIONAL
    VALIDATE_BACKUP_EMAIL
    ADD_DURESS_PASSWORD_OPTIONAL
    UNREGISTERED
}

type RegistrationError {
    errorCode: String!
    errorMessage: String!
}

type UserRegistrationStateResponse {
    userRegistrationState: UserRegistrationState!
    registrationError: RegistrationError! 
	accessToken: String
    tokenExpiresAtMs: Float
    totpSecret: String
	uri: String
}

type UserRegistrationState {
	userId: String!
    email: String!
    tenantId: String!
    registrationSessionToken: String!
	registrationState: RegistrationState!
    registrationStateOrder: Int!
    registrationStateStatus: String!
    preAuthToken: String
	expiresAtMs: Float!
    deviceCodeId: String
}


enum SecondFactorType {
    TOTP
    SECURITY_KEY
}


enum AuthenticationErrorTypes {
    ERROR_INVALID_USERNAME_OR_PASSWORD
    ERROR_CONDITIONS_FOR_AUTHENTICATION_NOT_MET
    ERROR_NO_MANAGEMENT_DOMAIN
    ERROR_NO_MATCHING_FEDERATED_PROVIDER_FOR_TENANT
    ERROR_EXCLUSIVE_TENANT_AND_NO_FEDERATED_OIDC_PROVIDER
    ERROR_NO_MATCHING_USER_AND_NO_TENANT_SELF_REGISTRATION
}


enum MarkForDeleteObjectType {
    TENANT
    CLIENT
    USER
    AUTHORIZATION_GROUP
    AUTHENTICATION_GROUP
    SCOPE
    FEDERATED_OIDC_PROVIDER
    RATE_LIMIT_SERVICE_GROUP
    SIGNING_KEY
}

type MarkForDelete {
    markForDeleteId: String!
    objectType: MarkForDeleteObjectType!
    objectId: String!
    submittedBy: String!
    submittedDate: Float!
    startedDate: Float
    completedDate: Float
}

type DeletionStatus {
    markForDeleteId: String!
    step: String!
    startedAt: Float!
    completedAt: Float
}


############################################################################
################ SEARCH TYPES AND RESPONSES FOR MUTATATIONS ################
############################################################################

enum SearchResultType {
    TENANT
    CLIENT
    USER
    AUTHORIZATION_GROUP
    AUTHENTICATION_GROUP
    ACCESS_CONTROL
    OIDC_PROVIDER
    RATE_LIMIT
    KEY
}

type ObjectSearchResultItem {
    objectid: String!    
    objecttype: SearchResultType!
    owningtenantid: String
    owningclientid: String
    name: String!
    description: String
    subtypekey: String
    subtype: String
    email: String
    enabled: Boolean    
}

type RelSearchResultItem {
    owningtenantid: String!
    owningtenantname: String
    parentid: String!
    parenttype: SearchResultType!
    parentname: String
    childid: String!
    childtype: SearchResultType!
    childname: String!
    childdescription: String
}


type ObjectSearchResults {
    starttime: Float!
    endtime: Float!
    took: Int!
    page: Int!
    perpage: Int!
    total: Int!
    resultlist: [ObjectSearchResultItem!]!
}

type RelSearchResults {
    starttime: Float!
    endtime: Float!
    took: Int!
    page: Int!
    perpage: Int!
    total: Int!
    resultlist: [RelSearchResultItem!]!
}

type LookaheadItem {
    id: String!
    matchingString: String
    displayValue: String!
}

type LookaheadResult {
    category: SearchResultType!
    resultList: [LookaheadItem!]!
}

enum SearchRelType {
    AUTHORIZATION_GROUP_USER_REL
    AUTHENTICATION_GROUP_USER_REL
    CLIENT_AUTHENTICATION_GROUP_REL
}
    

type UserMFARel {
    userId: String!
    mfaType: String!
    primaryMfa: Boolean!
    totpSecret: String
    totpHashAlgorithm: String
    fido2PublicKey: String
    fido2CredentialId: String
    fido2PublicKeyAlgorithm: Int
    fido2Transports: String
    fido2KeySupportsCounters: Boolean
}

type TOTPResponse {
    userMFARel: UserMFARel!
    uri: String!
}

type StateProvinceRegion {
    isoCountryCode: String!
    isoEntryCode: String!
    isoEntryName: String!
    isoSubsetType: String!
}

type Fido2Challenge {
    userId: String!
    challenge: String!
    issuedAtMs: Float!
    expiresAtMs: Float!
}

type Fido2RegistrationChallengeResponse {
    fido2Challenge: Fido2Challenge!
    userName: String!
    email: String!
    rpName: String!
    rpId: String!
}

type Fido2AuthenticationChallengePasskey {
    id: String!,
    transports: [String!]!
}

type Fido2AuthenticationChallengeResponse {
    fido2Challenge: Fido2Challenge!
    rpId: String!
    fido2AuthenticationChallengePasskeys: [Fido2AuthenticationChallengePasskey!]!
}

############################################################################
############ SYSTEM SETTINGS TYPES AND RESPONSES FOR MUTATATIONS ###########
############################################################################

type CategoryEntry {
    categoryKey: String!
    categoryValue: String!
}
type SystemCategory {
    categoryName: String!
    categoryEntries: [CategoryEntry!]!

}

type SystemSettings {
    softwareVersion: String!
    allowBackupEmail: Boolean!
    allowDuressPassword: Boolean!
    rootClientId: String!
    enablePortalAsLegacyIdp: Boolean!
    systemCategories: [SystemCategory!]!
}

type JobData {
    markForDeleteItems: [MarkForDelete!]!
    schedulerLocks: [SchedulerLock!]!
}


############################################################################
############## SECRET ENTRY TYPES AND RESPONSES FOR MUTATATIONS ############
############################################################################

enum SecretShareObjectType {
    OIDC_PROVIDER
}

type SecretShare {
    secretShareId: String!
    objectId: String!
    secretShareObjectType: SecretShareObjectType!
    otp: String!
    expiresAtMs: Float!
}


############################################################################
################ INPUT TYPES AND RESPONSES FOR MUTATATIONS #################
############################################################################


enum SearchFilterInputObjectType {
    TENANT_ID
    CLIENT_ID
    USER_ID
    AUTHORIZATION_GROUP_ID
    AUTHENTICATION_GROUP_ID
}

input SearchFilterInput {
    objectType: SearchFilterInputObjectType!
    objectValue: String!
}


input SearchInput {
    term: String
    resultType: SearchResultType
    filters: [SearchFilterInput]
    page: Int!
    perPage: Int!
    sortField: String
    sortDirection: String
}

input RelSearchInput {
    term: String
    owningtenantid: String
    parenttype: SearchResultType
    parentid: String  
    childtype: SearchResultType
    childid: String
    childids: [String]
    page: Int!
    perPage: Int!
    sortField: String
    sortDirection: String
}

input FederatedOIDCProviderCreateInput {
    federatedOIDCProviderName: String!
    federatedOIDCProviderDescription: String
    federatedOIDCProviderTenantId: String
    federatedOIDCProviderClientId: String!
    federatedOIDCProviderClientSecret: String
    federatedOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    usePkce: Boolean!
    federatedOIDCProviderType: String!
    federatedoidcprovidertypeid: String
    clientAuthType: String!
    clientauthtypeid: String
    scopes: [String!]!
    socialLoginProvider: String
}

input FederatedOIDCProviderUpdateInput {
    federatedOIDCProviderId: String!
    federatedOIDCProviderName: String!
    federatedOIDCProviderDescription: String
    federatedOIDCProviderTenantId: String
    federatedOIDCProviderClientId: String!
    federatedOIDCProviderClientSecret: String
    federatedOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    usePkce: Boolean!
    federatedOIDCProviderType: String!
    federatedoidcprovidertypeid: String
    clientAuthType: String!
    clientauthtypeid: String
    scopes: [String!]!
    socialLoginProvider: String
}


input ContactCreateInput {
    objectid: String!
    objecttype: String!
    email: String!
    name: String
    userid: String
}


input PasswordConfigInput {
    tenantId: String!
    passwordMinLength: Int!
    passwordMaxLength: Int! 
    passwordHashingAlgorithm: String!
    requireUpperCase: Boolean!
	requireLowerCase: Boolean!
	requireNumbers: Boolean!
	requireSpecialCharacters: Boolean!
	specialCharactersAllowed: String
    requireMfa: Boolean!
    mfaTypesRequired: String
    maxRepeatingCharacterLength: Int
    passwordRotationPeriodDays: Int
    passwordHistoryPeriod: Int
}

input TenantAnonymousUserConfigInput {
    tenantId: String!
    defaultcountrycode: String
    defaultlangugecode: String
    tokenttlseconds: Int!
}

input TenantCreateInput {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    allowAnonymousUsers: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    allowSocialLogin: Boolean!
    federatedAuthenticationConstraint: String!    
    tenantType: String!
    migrateLegacyUsers: Boolean!
    allowLoginByPhoneNumber: Boolean!
    allowForgotPassword: Boolean!
    defaultRateLimit: Int
    defaultRateLimitPeriodMinutes: Int
    registrationRequireTermsAndConditions: Boolean!
    termsAndConditionsUri: String
    registrationRequireCaptcha: Boolean!
}

input TenantUpdateInput {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    allowAnonymousUsers: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    allowSocialLogin: Boolean!
    federatedAuthenticationConstraint: String!
    tenantType: String!
    migrateLegacyUsers: Boolean!
    allowLoginByPhoneNumber: Boolean!
    allowForgotPassword: Boolean!
    defaultRateLimit: Int
    defaultRateLimitPeriodMinutes: Int
    registrationRequireTermsAndConditions: Boolean!
    termsAndConditionsUri: String
    registrationRequireCaptcha: Boolean!
}

input TenantLegacyUserMigrationConfigInput {
    tenantId: String!
    authenticationUri: String!
    userProfileUri: String!
    usernameCheckUri: String!
}

input FooterLinkInput {
    footerlinkid: String
    tenantid: String!
    linktext: String!
    uri: String!
}

input TenantLookAndFeelInput {
    tenantid: String!
    adminheaderbackgroundcolor: String
    adminheadertextcolor: String
    adminlogo: String
    adminheadertext: String
    authenticationheaderbackgroundcolor: String
    authenticationheadertextcolor: String
    authenticationlogo: String
    authenticationlogomimetype: String
    authenticationheadertext: String
    footerlinks: [FooterLinkInput]
}

input ClientCreateInput {
    tenantId: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean!
    oidcEnabled: Boolean!
    pkceEnabled: Boolean!
    clientType: String!
    clienttypeid: String
    userTokenTTLSeconds: Int
    clientTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
}

input ClientUpdateInput {
    tenantId: String!
    clientId: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean!
    oidcEnabled: Boolean!
    pkceEnabled: Boolean!
    clientType: String!
    clienttypeid: String
    userTokenTTLSeconds: Int
    clientTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
}

input SigningKeyCreateInput {
    tenantId: String!    
    keyType: String!
    keyTypeId: String
    keyName: String!
    keyUse: String!
    privateKeyPkcs8: String!
    password: String
    certificate: String
    publicKey: String
    expiresAtMs: Float
}

input AutoCreateSigningKeyInput {
    tenantId: String!
    keyType: String!
    keyTypeId: String
    keyName: String!
    keyUse: String!
    password: String
    commonName: String!
    organizationName: String!
    expiresAtMs: Float!
}

input SigningKeyUpdateInput {
    keyId: String!
    status: String!
    keyName: String
    keyUse: String
}


input RateLimitServiceGroupCreateInput {
    servicegroupname: String!
    servicegroupdescription: String
}

input RateLimitServiceGroupUpdateInput {
    servicegroupid: String!
    servicegroupname: String!
    servicegroupdescription: String
}

input ScopeCreateInput {
    scopeName: String!
    scopeDescription: String!
    scopeUse: String!
    scopeAccessRuleSchemaId: String
}

input ScopeUpdateInput {
    scopeId: String!
    scopeName: String!
    scopeDescription: String!
    scopeAccessRuleSchemaId: String
}

input AuthenticationGroupCreateInput {
    tenantId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
    defaultGroup: Boolean!
}

input AuthenticationGroupUpdateInput {
    tenantId: String!
    authenticationGroupId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
    defaultGroup: Boolean!
}

input AuthorizationGroupCreateInput {
    tenantId: String!
    groupName: String!
    groupDescription: String
    default: Boolean!
    allowForAnonymousUsers: Boolean!
}

input AuthorizationGroupUpdateInput {
    tenantId: String!
    groupId: String!
    groupName: String!
    groupDescription: String
    default: Boolean!
    allowForAnonymousUsers: Boolean!
}

## Scope constraint schemas
input ScopeAccessRuleSchemaCreateInput {
    scopeId: String!
    schema: String!
}

input ScopeAccessRuleSchemaUpdateInput {
    scopeAccessRuleSchemaId: String!
    scopeId: String!
    schema: String!
}

input BulkScopeInput {
    scopeId: String!
    accessRuleId: String
}

## Access rules
input AccessRuleCreateInput {
    accessRuleName: String!
    scopeAccessRuleSchemaId: String!
    accessRuleDefinition: String!
}

input AccessRuleUpdateInput {
    accessRuleId: String!
    accessRuleName: String!
    scopeAccessRuleSchemaId: String!
    accessRuleDefinition: String!
}

input TenantLoginFailurePolicyInput {
    tenantId: String!
    loginFailurePolicyType: String!
    failureThreshold: Int!
    pauseDurationMinutes: Int
    maximumLoginFailures: Int
}

input UserCreateInput {
    federatedOIDCProviderSubjectId: String
    email: String!    
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    addressLine1: String
    city: String
    postalCode: String
    stateRegionProvince: String
    countryCode: String
    preferredLanguageCode: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
    password: String!
    termsAndConditionsAccepted: Boolean!
}

input UserUpdateInput {
    userId: String!
    federatedOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    addressLine1: String
    city: String
    postalCode: String
    stateRegionProvince: String
    countryCode: String
    preferredLanguageCode: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
}

input MarkForDeleteInput {
    markForDeleteObjectType: MarkForDeleteObjectType!
    objectId: String!
}


input AuthenticatorAttestationResponseInput {
    clientDataJSON: String!
    attestationObject: String!
    authenticatorData: String!
    transports: [String!]!
    publicKeyAlgorithm: Int!
    publicKey: String!
}

input Fido2KeyRegistrationInput {
    id: String!
    rawId: String!
    response: AuthenticatorAttestationResponseInput!
    type: String!
    authenticationAttachment: String!
}

input AuthenticatorAuthenticationResponseInput {
    authenticatorData: String!
    clientDataJSON: String!
    signature: String!
}

input Fido2KeyAuthenticationInput {
    id: String!
    rawId: String!
    type: String!
    authenticationAttachment: String!
    response: AuthenticatorAuthenticationResponseInput!
}

input CaptchaConfigInput {
    alias: String!
    projectId: String
    siteKey: String!
    apiKey: String!
    minScopeThreshold: Float
    useCaptchaV3: Boolean!
}

input SystemSettingsUpdateInput {
    allowBackupEmail: Boolean!
    allowDuressPassword: Boolean!
    rootClientId: String!
    enablePortalAsLegacyIdp: Boolean!
}

type Query {
    ## Tenants
    getRootTenant: Tenant!
    getTenants: [Tenant!]!
    getTenantById(tenantId: String!): Tenant

    ## Clients
    getClients(tenantId: String!): [Client!]!
    getClientById(clientId: String!): Client

    ## Users
    getUsers(tenantId: String): [User!]!
    getUserById(userId: String!): User
    
    ## Keys
    getSigningKeys(tenantId: String): [SigningKey!]!
    getSigningKeyById(signingKeyId: String!): SigningKey

    ## RateLimit
    getRateLimits(tenantId: String): [RateLimit!]!
    getRateLimitById(rateLimitId: String!): RateLimit

    ## Scope
    getScope(tenantId: String): [Scope!]!
    getScopeById(scopeId: String!): Scope

    ## Scope constraints
    getScopeConstraintSchemas: [ScopeConstraintSchema!]!
    getScopeConstraintSchemaById(scopeConstraintSchemaId: String): ScopeConstraintSchema

    ## Access rules
    getAccessRules(tenantId: String): [AccessRule!]!
    getAccessRuleById(accessRuleId: String!): AccessRule

    ## AuthenticationGroups
    getAuthenticationGroups(tenantId: String): [AuthenticationGroup!]!
    getAuthenticationGroupById(authenticationGroupId: String!): AuthenticationGroup

    ## Groups
    getGroups: [Group!]!
    getGroupById(groupId: String!): Group
    getUserGroups(userId: String!): [Group!]!

    ## External OIDC Providers
    getExternalOIDCProviders(tenantId: String): [ExternalOIDCProvider!]!
    getExternalOIDCProviderById(externalOIDCProviderId: String!): ExternalOIDCProvider
    
}

type Mutation {
    ## Tenants
    createRootTenant(tenantInput: TenantCreateInput!): Tenant
    updateRootTenant(tenantInput: TenantUpdateInput!): Tenant
    
    createTenant(tenantInput: TenantCreateInput!): Tenant
    updateTenant(tenantInput: TenantUpdateInput!): Tenant
    deleteTenant(tenantId: String!): String

    ## Clients
    createClient(clientInput: ClientCreateInput!): Client
    updateClient(clientInput: ClientUpdateInput!): Client
    ## Just returns the ID after deletion is complete
    deleteClient(clientId: String!): String

    ## Users

    
    ## Keys
    createSigningKey(keyInput: SigningKeyCreateInput!): SigningKey!
    deleteSigningKey(keyId: String!): String!

    ## RateLimit
    createRateLimit(rateLimitInput: RateLimitCreateInput!): RateLimit
    updateRateLimit(rateLimitInput: RateLimitUpdateInput!): RateLimit
    deleteRateLimit(rateLimitId: String!): String
    assignRateLimitToTenant(tenantId: String!, rateLimitId: String!, allowUnlimited: Boolean, limit: Int, rateLimitPeriodMinutes: Int): TenantRateLimitRel
    updateRateLimitForTenant(tenantId: String!, rateLimitId: String!, allowUnlimited: Boolean, limit: Int, rateLimitPeriodMinutes: Int): TenantRateLimitRel
    removeRateLimitFromTenant(tenantId: String!, rateLimitId: String!): String

    ## Scope
    createScope(scopeInput: ScopeCreateInput!): Scope
    updateScope(scopeInput: ScopeUpdateInput!): Scope
    deleteScope(scopeId: String!): String
    assignScopeToTenant(tenantId: String!, scopeId: String!): TenantScopeRel
    removeScopeFromTenant(tenantId: String!, scopeId: String!): String
    assignScopeToClient(tenantId: String!, clientId: String!, scopeId: String!): ClientTenantScopeRel
    removeScopeFromClient(tenantId: String!, clientId: String!, scopeId: String!): String

    ## Scope constraint schemas
    createScopeConstraintSchema(scopeConstraintSchemaInput: ScopeConstraintSchemaCreateInput!): ScopeConstraintSchema
    updateScopeConstraintSchema(scopeConstraintSchemaInput: ScopeConstraintSchemaUpdateInput!): ScopeConstraintSchema
    deleteScopeConstraingSchema(scopeConstraintSchemaId: String!): String!

    ## Access rules
    createAccessRule(accessRuleInput: AccessRuleCreateInput!): AccessRule
    updateAccessRule(accessRuleInput: AccessRuleUpdateInput!): AccessRule
    deleteAccessRule(accessRuleId: String!): String!

    ## AuthenticationGroups
    createAuthenticationGroup(authenticationGroupInput: AuthenticationGroupCreateInput!): AuthenticationGroup
    updateAuthenticationGroup(authenticationGroupInput: AuthenticationGroupUpdateInput!): AuthenticationGroup
    deleteAuthenticationGroup(authenticationGroupId: String!): String!
    assignAuthenticationGroupToClient(authenticationGroupId: String!, clientId: String!): AuthenticationGroupClientRel
    removeAuthenticationGroupFromClient(authenticationGroupId: String!, clientId: String!): String
    
    ## Groups
    createGroup(groupInput: GroupCreateInput!): Group
    updateGroup(groupInput: GroupUpdateInput!): Group
    deleteGroup(groupId: String!): String!
    addUserToGroup(userId: String!, groupId: String!): UserGroupRel
    removeUserFromGroup(userId: String!, groupId: String!): String

    ## External OIDC Providers
    createExternalOIDCProvider(oidcProviderInput: ExternalOIDCProviderCreateInput!): ExternalOIDCProvider
    updateExternalOIDCProvider(oidcProviderInput: ExternalOIDCProviderUpdateInput!): ExternalOIDCProvider
    assignExternalOIDCProviderToTenant(externalOIDCProviderId: String!, tenantId: String!): ExternalOIDCProviderTenantRel!
    removeExternalOIDCProviderFromTenant(externalOIDCProviderId: String!, tenantId: String!): ExternalOIDCProviderTenantRel!
    assignExternalOIDCProviderToDomain(externalOIDCProviderId: String!, domain: String!): ExternalOIDCProviderDomainRel!
    removeExternalOIDCProviderFromDomain(externalOIDCProviderId: String!, domain: String!): ExternalOIDCProviderDomainRel!
    deleteExternalOIDCProvider(externalOIDCProviderId: String!): String!

}


# NOT_ALLOWED - No external OIDC provider can be attached to this tenant
# EXCLUSIVE   - Use ONLY the single OIDC provider that is configured in the Rel table
# PERMISSIVE  - Allow many different external OIDC providers to be attached to this tenant
enum DelegatedAuthenticationConstraint {
    NOT_ALLOWED
    EXCLUSIVE
    PERMISSIVE
}

########
# 1.    tenantId -           Write once, read only
# 2.    enabled -            true | false
# 3.    allowedScopeValues - ALL of the scopes that are available for the tenant. A subset of these are
#                            available to each of the clients
# 4.    claimsSupported -    Of all of the OIDC claims, which does this tenant support
# 5.    allowUnlimitedRate - true | false. True will override any rate limit set in the rateLimits property

type Tenant {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    claimsSupported: [String!]!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    delegatedAuthenticationConstraint: DelegatedAuthenticationConstraint!
    markForDelete: Boolean!
    externalOIDCProviderId: String
}

enum ClientAuthType {
    CLIENT_SECRET_POST
    CLIENT_SECRET_BASIC
    CLIENT_SECRET_JWT
    NONE
}

# Either client secret should be defined or usePkce should be set to true
# if no client secret, then client auth type should be NONE
# refreshTokenAllowed - does the external provider allow for refresh tokens? default false 
type ExternalOIDCProvider {
    externalOIDCProviderId: String!
    externalOIDCProviderName: String!
    externalOIDCProviderDescription: String
    externalOIDCProviderTenantId: String
    externalOIDCProviderClientId: String!
    externalOIDCProviderClientSecret: String
    externalOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    usePkce: Boolean!
    clientAuthType: ClientAuthType
}

type ExternalOIDCProviderTenantRel {    
    externalOIDCProviderId: String!
    tenantId: String!
}

type ExternalOIDCProviderDomainRel {
    externalOIDCProviderId: String!
    domain: String!
}


enum ClientType {
    SERVICE_ACCOUNT_ONLY
    SERVICE_ACCOUNT_AND_USER_DELEGATED_PERMISSIONS
    USER_DELEGATED_PERMISSIONS_ONLY
}


# 1.    tenantId -      Parent tenant (write once, read only)
# 2.    clientId -      GUID
# 3.    clientSecret -  A 256-bit hex-encoded value
# 4.    clientName
# 5.    clientDescription
# 6.    enabled -       true | false
# 7.    redirectUris - List of redirect URIs for authorization
# 8.    oidcEnabled -  Allow SSO for this client
# 9.    pkceEnabled
# 10.   clientType
# 11.   userTokenTTLSeconds default is 60 minutes, configurable up to 12 hours
# 12.   allowUserSelfRegistration default false
# 13.   allowDelegatedAuthentication default false
type Client {
    tenantId: String!
    clientId: String!
    clientSecret: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean
    redirectUris: [String!]
    oidcEnabled: Boolean!
    pkceEnabled: Boolean!
    clientType: ClientType!
    userTokenTTLSeconds: Int!
    maxRefreshTokenCount: Int
}

enum TwoFactorAuthType {
    NONE
    TEXT
    EMAIL
    TIME_BASED_OTP
    HARDWARE
}

# 1.    domain is just the domain part of the email
type User {
    userId: String!
    externalOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    createdDate: String!
    updatedDate: String
    countryCode: String
    preferredLanguageCode: String
    twoFactorAuthType: TwoFactorAuthType
}

type UserTenantRel {
    userId: String!
    tenantId: String!
}

type AuthenticationGroup {
    tenantId: String!
    authenticationGroupId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
}

type AuthenticationGroupClientRel {
    clientId: String!
    authenticationGroupId: String!
}

type AuthenticationGroupUserRel {
    authenticationGroupId: String!
    userId: String!
}

# default - for newly registered or created users within the tenant, assign to any group 
# in the tenant that is marked with default
type Group {
    tenantId: String!
    groupId: String!
    groupName: String!
    default: Boolean!
}

type UserGroupRel {
    userId: String!
    groupId: String!
}

type UserCredential {
    userId: String!
    salt: String!
    hashedPassword: String!
}

type UserCredentialHistory {
    userId: String!
    salt: String!
    hashedPassword: String!
    hashingAlgorithm: String!
    dateCreated: String!    
}

enum KeyType {
    RSA,
    EC
}
type SigningKey {
    keyId: String!
    tenantId: String!    
    keyType: KeyType!
    use: String!
    privateKey: String!
    password: String
    certificate: String!
}



# 1.    rateLimitId
# 2.    rateLimitDomain  -  User-defined name of the context or other identifier which will be used by the application
#                           to make rate limiting decisions. If you need just one then it can be global.
# 3.    rateLimitDescription  -  
type RateLimit {
    rateLimitId: String!
    rateLimitDomain: String!
    rateLimitDescription: String
}

type TenantRateLimitRel {
    tenantId: String!
    rateLimitId: String!
    allowUnlimitedRate: Boolean
    rateLimit: Int
    rateLimitPeriodMinutes: Int
}

# Can optionally have a constraint definition tied to this scope.
# Not a requirement, but if one exists, then you MAY, if you choose,
# create an access rule that you can apply to the tenant (and so the 
# client and groups which belong to the tenant) which have this scope.
type Scope {
    scopeId: String!
    scopeName: String!
    scopeDescription: String
    scopeConstraintSchemaId: String
}

# Access rules CAN be applied at the tenant level for any non-Root tenant
# Any client or group will automatically inherit these restrictions
type TenantScopeRel {
    tenantId: String!
    scopeId: String!
    accessRuleId: String
}

type ClientTenantScopeRel {
    tenantId: String!
    clientId: String!
    scopeId: String!
}

type GroupScopeRel {
    groupId: String!
    tenantId: String!
    scopeId: String!
}

type ScopeConstraintSchema {
    scopeConstraintSchemaId: String!
    schemaVersion: Int!
    scopeId: String!
    schema: String!
}

type AccessRule {
    accessRuleId: String!
    scopeId: String!
    scopeConstraintSchemaId: String!
    accessRuleDefinition: String!
}


############################################################################
################ INPUT TYPES AND RESPONSES FOR MUTATATIONS #################
############################################################################

input ExternalOIDCProviderCreateInput {
    externalOIDCProviderId: String!
    externalOIDCProviderName: String!
    externalOIDCProviderDescription: String
    externalOIDCProviderTenantId: String
    externalOIDCProviderClientId: String!
    externalOIDCProviderClientSecret: String
    externalOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    usePkce: Boolean!
    clientAuthType: ClientAuthType
}

input ExternalOIDCProviderUpdateInput {
    externalOIDCProviderId: String!
    externalOIDCProviderName: String!
    externalOIDCProviderDescription: String
    externalOIDCProviderTenantId: String
    externalOIDCProviderClientId: String!
    externalOIDCProviderClientSecret: String
    externalOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    usePkce: Boolean!
    clientAuthType: ClientAuthType
}

input TenantCreateInput {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    claimsSupported: [String!]!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    delegatedAuthenticationConstraint: DelegatedAuthenticationConstraint!
    externalOIDCProviderId: String
    maxRefreshTokenCount: Int
}

input TenantUpdateInput {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    claimsSupported: [String!]!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    delegatedAuthenticationConstraint: DelegatedAuthenticationConstraint!
    externalOIDCProviderId: String
    markForDelete: Boolean!
    maxRefreshTokenCount: Int
}

input ClientCreateInput {
    tenantId: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean
    redirectUris: [String!]
    oidcEnabled: Boolean
    pkceEnabled: Boolean
    clientType: ClientType!
    userTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
}

input ClientUpdateInput {
    tenantId: String!
    clientId: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean
    redirectUris: [String!]
    oidcEnabled: Boolean
    pkceEnabled: Boolean
    clientType: ClientType!
    userTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
}

input SigningKeyCreateInput {
    tenantId: String!    
    keyType: KeyType!
    use: String!
    privateKey: String!
    password: String
    certificate: String!
}


input RateLimitCreateInput {
    rateLimitDomain: String!
    rateLimitDescription: String
}

input RateLimitUpdateInput {
    rateLimitId: String!
    rateLimitDomain: String!
    rateLimitDescription: String
}
input ScopeCreateInput {
    scopeName: String!
    scopeDescription: String
    scopeConstraintSchemaId: String
}

input ScopeUpdateInput {
    scopeId: String!
    scopeName: String!
    scopeDescription: String
    scopeConstraintSchemaId: String
}

input AuthenticationGroupCreateInput {
    tenantId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
}

input AuthenticationGroupUpdateInput {
    tenantId: String!
    authenticationGroupId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
}

input GroupCreateInput {
    tenantId: String!
    groupName: String!
    default: Boolean!
}

input GroupUpdateInput {
    tenantId: String!
    groupId: String!
    groupName: String!
    default: Boolean!
}

## Scope constraint schemas
input ScopeConstraintSchemaCreateInput {
    scopeId: String!
    schema: String!
}

input ScopeConstraintSchemaUpdateInput {
    scopeConstraintSchemaId: String!
    scopeId: String!
    schema: String!
}

## Access rules
input AccessRuleCreateInput {
    scopeId: String!
    scopeConstraintSchemaId: String!
    accessRuleDefinition: String!
}

input AccessRuleUpdateInput {
    accessRuleId: String!
    scopeId: String!
    scopeConstraintSchemaId: String!
    accessRuleDefinition: String!
}

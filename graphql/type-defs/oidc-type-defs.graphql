
type Query {


    ## Search
    search(searchInput: SearchInput!): ObjectSearchResults!
    lookahead(term: String!): [LookaheadResult!]!
    relSearch(relSearchInput: RelSearchInput!): RelSearchResults!


    ## Tenants
    getRootTenant: Tenant!
    getTenants(tenantIds: [String!], federatedOIDCProviderId: String, scopeId: String): [Tenant!]!
    getTenantById(tenantId: String!): Tenant
    getTenantMetaData(tenantId: String!): TenantMetaData
    getDomainsForTenantManagement(tenantId: String!): [TenantManagementDomainRel!]!
    getDomainsForTenantAuthentication(tenantId: String!): [TenantRestrictedAuthenticationDomainRel!]!
    getAnonymousUserConfiguration(tenantId: String!): TenantAnonymousUserConfiguration
    getLegacyUserMigrationConfiguration(tenantId: String!): TenantLegacyUserMigrationConfig
    getTenantLookAndFeel(tenantId: String!): TenantLookAndFeel
    getTenantPasswordConfig(tenantId: String!): TenantPasswordConfig

    ## Clients
    getClients(tenantId: String): [Client!]!
    getClientById(clientId: String!): Client
    getRedirectURIs(clientId: String!): [String!]!

    ## Users
    getUsers(tenantId: String): [User!]!
    getUserById(userId: String!): User
    getLoginUserNameHandler(username: String!, tenantId: String, preauthToken: String): LoginUserNameHandlerResponse!
    getUserTenantRels(userId: String!): [UserTenantRelView!]!
    validateTOTP(userId: String!, totpValue: String!): Boolean!

    ## For tenant management and access
    me: PortalUserProfile
    
    ## Keys
    getSigningKeys(tenantId: String): [SigningKey!]!
    getSigningKeyById(signingKeyId: String!): SigningKey

    ## RateLimit
    getRateLimitServiceGroups(tenantId: String): [RateLimitServiceGroup!]!
    getRateLimitServiceGroupById(serviceGroupId: String!): RateLimitServiceGroup
    getRateLimitTenantRels(tenantId: String, rateLimitServiceGroupId: String): [TenantRateLimitRel!]!
    getRateLimitTenantRelViews(rateLimitServiceGroupId: String, tenantId: String): [TenantRateLimitRelView!]!

    ## Scope
    getScope(tenantId: String, filterBy: ScopeFilterCriteria): [Scope!]!
    getScopeById(scopeId: String!): Scope
    getClientScopes(clientId: String!): [Scope!]!
    getAuthorizationGroupScopes(groupId: String!): [Scope!]!
    getUserScopes(userId: String!): [Scope!]!


    ## Scope constraints
    getScopeAccessRuleSchemas: [ScopeAccessRuleSchema!]!
    getScopeAccessRuleSchemaById(scopeAccessRuleSchemaId: String): ScopeAccessRuleSchema

    ## Access rules
    getAccessRules(tenantId: String): [AccessRule!]!
    getAccessRuleById(accessRuleId: String!): AccessRule

    ## AuthenticationGroups
    getAuthenticationGroups(tenantId: String, clientId: String, userId: String): [AuthenticationGroup!]!
    getAuthenticationGroupById(authenticationGroupId: String!): AuthenticationGroup

    ## Groups
    getAuthorizationGroups(tenantId: String): [AuthorizationGroup!]!
    getAuthorizationGroupById(groupId: String!): AuthorizationGroup
    getUserAuthorizationGroups(userId: String!): [AuthorizationGroup!]!

    ## External OIDC Providers
    getFederatedOIDCProviders(tenantId: String): [FederatedOIDCProvider!]!
    getFederatedOIDCProviderById(federatedOIDCProviderId: String!): FederatedOIDCProvider
    getFederatedOIDCProviderDomainRels(federatedOIDCProviderId: String, domain: String): [FederatedOIDCProviderDomainRel!]!

    
    ## Change events
    getChangeEvents(objectId: String!): [ChangeEvent!]!

    ## Login Failure Configuration
    getLoginFailurePolicy(tenantId: String!): LoginFailurePolicy

    ## Scheduler
    getSchedulerLocks: [SchedulerLock]

    ## Contacts
    getContacts(objectId: String!): [Contact!]!

    ## Viewing secrets or private keys
    getSecretValue(objectId: String!, objectType: SecretObjectType!): String

    ## Mark for deletion
    getMarkForDeleteById(markForDeleteId: String!): MarkForDelete
    getDeletionStatus(markForDeleteId: String!): [DeletionStatus!]!

}

type Mutation {
    ## Tenants
    createRootTenant(tenantInput: TenantCreateInput!): Tenant
    updateRootTenant(tenantInput: TenantUpdateInput!): Tenant
    
    createTenant(tenantInput: TenantCreateInput!): Tenant
    updateTenant(tenantInput: TenantUpdateInput!): Tenant
    deleteTenant(tenantId: String!): String
    addDomainToTenantManagement(tenantId: String!, domain: String!): TenantManagementDomainRel
    removeDomainFromTenantManagement(tenantId: String!, domain: String!): String
    addDomainToTenantRestrictedAuthentication(tenantId: String!, domain: String!): TenantRestrictedAuthenticationDomainRel
    removeDomainFromTenantRestrictedAuthentication(tenantId: String!, domain: String!): String
    setTenantPasswordConfig(passwordConfigInput: PasswordConfigInput!): TenantPasswordConfig
    removeTenantPasswordConfig(tenantId: String!): String
    setTenantLegacyUserMigrationConfig(tenantLegacyUserMigrationConfigInput: TenantLegacyUserMigrationConfigInput!): TenantLegacyUserMigrationConfig
    removeTenantLegacyUserMigrationConfig(tenantId: String!): String
    setTenantAnonymousUserConfig(tenantAnonymousUserConfigInput: TenantAnonymousUserConfigInput!): TenantAnonymousUserConfiguration
    removeTenantAnonymousUserConfig(tenantId: String!): String
    setTenantLookAndFeel(tenantLookAndFeelInput: TenantLookAndFeelInput!): TenantLookAndFeel    
    removeTenantLookAndFeel(tenantId: String!): String
    
    ## Clients
    createClient(clientInput: ClientCreateInput!): Client
    updateClient(clientInput: ClientUpdateInput!): Client
    ## Just returns the ID after deletion is complete
    deleteClient(clientId: String!): String
    addRedirectURI(clientId: String!, uri: String!): String
    removeRedirectURI(clientId: String!, uri: String!): String
    assignAuthenticationGroupToClient(authenticationGroupId: String!, clientId: String!): AuthenticationGroupClientRel
    removeAuthenticationGroupFromClient(authenticationGroupId: String!, clientId: String!): String

    ## Users
    logout(userId: String): String
    login(username: String!, password: String!): LoginAuthenticationHandlerResponse!
    createUser(tenantId: String!, userInput: UserCreateInput!): User!
    updateUser(userInput: UserUpdateInput!): User!
    updateUserTenantRel(tenantId: String!, userId: String!, relType: String!): UserTenantRel!
    assignUserToTenant(tenantId: String!, userId: String!, relType: String!): UserTenantRel!
    removeUserFromTenant(tenantId: String!, userId: String!): String
    generateTOTP(userId: String!): TOTPResponse
      
    
    ## Keys
    createSigningKey(keyInput: SigningKeyCreateInput!): SigningKey!
    updateSigningKey(keyInput: SigningKeyUpdateInput!): SigningKey!
    deleteSigningKey(keyId: String!): String!

    ## RateLimit
    createRateLimitServiceGroup(rateLimitServiceGroupInput: RateLimitServiceGroupCreateInput!): RateLimitServiceGroup
    updateRateLimitServiceGroup(rateLimitServiceGroupInput: RateLimitServiceGroupUpdateInput!): RateLimitServiceGroup
    deleteRateLimitServiceGroup(serviceGroupId: String!): String
    assignRateLimitToTenant(tenantId: String!, serviceGroupId: String!, allowUnlimited: Boolean, limit: Int, rateLimitPeriodMinutes: Int): TenantRateLimitRel
    updateRateLimitForTenant(tenantId: String!, serviceGroupId: String!, allowUnlimited: Boolean, limit: Int, rateLimitPeriodMinutes: Int): TenantRateLimitRel
    removeRateLimitFromTenant(tenantId: String!, serviceGroupId: String!): String

    ## Scope
    createScope(scopeInput: ScopeCreateInput!): Scope
    updateScope(scopeInput: ScopeUpdateInput!): Scope
    deleteScope(scopeId: String!): String
    assignScopeToTenant(tenantId: String!, scopeId: String!, accessRuleId: String): TenantAvailableScope
    removeScopeFromTenant(tenantId: String!, scopeId: String!): String
    assignScopeToClient(clientId: String!, tenantId: String!, scopeId: String!): ClientScopeRel
    removeScopeFromClient(clientId: String!, tenantId: String!, scopeId: String!): String
    assignScopeToAuthorizationGroup(groupId: String!, scopeId: String!): AuthorizationGroupScopeRel
    removeScopeFromAuthorizationGroup(groupId: String!, scopeId: String!): String
    assignScopeToUser(userId: String!, tenantId: String!, scopeId: String!): UserScopeRel
    removeScopeFromUser(userId: String!, tenantId: String!, scopeId: String!): String

    ## Scope constraint schemas
    createScopeAccessRuleSchema(scopeAccessRuleSchemaInput: ScopeAccessRuleSchemaCreateInput!): ScopeAccessRuleSchema
    updateScopeAccessRuleSchema(scopeAccessRuleSchemaInput: ScopeAccessRuleSchemaUpdateInput!): ScopeAccessRuleSchema
    deleteScopeAccessRuleSchema(scopeAccessRuleSchemaId: String!): String!

    ## Access rules
    createAccessRule(accessRuleInput: AccessRuleCreateInput!): AccessRule
    updateAccessRule(accessRuleInput: AccessRuleUpdateInput!): AccessRule
    deleteAccessRule(accessRuleId: String!): String!

    ## AuthenticationGroups
    createAuthenticationGroup(authenticationGroupInput: AuthenticationGroupCreateInput!): AuthenticationGroup
    updateAuthenticationGroup(authenticationGroupInput: AuthenticationGroupUpdateInput!): AuthenticationGroup
    deleteAuthenticationGroup(authenticationGroupId: String!): String!
    addUserToAuthenticationGroup(authenticationGroupId: String!, userId: String!): AuthenticationGroupUserRel
    removeUserFromAuthenticationGroup(authenticationGroupId: String!, userId: String!): String
    
    ## Groups
    createAuthorizationGroup(groupInput: AuthorizationGroupCreateInput!): AuthorizationGroup
    updateAuthorizationGroup(groupInput: AuthorizationGroupUpdateInput!): AuthorizationGroup
    deleteAuthorizationGroup(groupId: String!): String!
    addUserToAuthorizationGroup(userId: String!, groupId: String!): AuthorizationGroupUserRel
    removeUserFromAuthorizationGroup(userId: String!, groupId: String!): String

    ## External OIDC Providers
    createFederatedOIDCProvider(oidcProviderInput: FederatedOIDCProviderCreateInput!): FederatedOIDCProvider
    updateFederatedOIDCProvider(oidcProviderInput: FederatedOIDCProviderUpdateInput!): FederatedOIDCProvider
    assignFederatedOIDCProviderToTenant(federatedOIDCProviderId: String!, tenantId: String!): FederatedOIDCProviderTenantRel!
    removeFederatedOIDCProviderFromTenant(federatedOIDCProviderId: String!, tenantId: String!): FederatedOIDCProviderTenantRel!
    assignFederatedOIDCProviderToDomain(federatedOIDCProviderId: String!, domain: String!): FederatedOIDCProviderDomainRel!
    removeFederatedOIDCProviderFromDomain(federatedOIDCProviderId: String!, domain: String!): FederatedOIDCProviderDomainRel!
    deleteFederatedOIDCProvider(federatedOIDCProviderId: String!): String!

    ## Login failure policy
    ## createLoginFailurePolicy(loginFailurePolicyInput: LoginFailurePolicyInput!): LoginFailurePolicy!
    updateLoginFailurePolicy(loginFailurePolicyInput: LoginFailurePolicyInput!): LoginFailurePolicy!

    ## Scheduler locks
    deleteSchedulerLock(instanceId: String!): String!

    ## Contacts
    addContact(contactCreateInput: ContactCreateInput!): Contact!
    removeContact(contactId: String!): String!

    ## Mark for deletion
    markForDelete(markForDeleteInput: MarkForDeleteInput!): MarkForDelete    

}

enum ScopeFilterCriteria {
    EXISTING
    AVAILABLE
}

enum SecretObjectType {
    CLIENT_SECRET
    PRIVATE_KEY
    PRIVATE_KEY_PASSWORD
    OIDC_PROVIDER_CLIENT_SECRET
}

type LoginFailurePolicy {
    tenantId: String!
    loginFailurePolicyType: String!
    loginfailurepolicytypeid: String
    failureThreshold: Int!
    pauseDurationMinutes: Int
    numberOfPauseCyclesBeforeLocking: Int
    initBackoffDurationMinutes: Int
    numberOfBackoffCyclesBeforeLocking: Int
}

########
# 1.    tenantId -           Write once, read only
# 2.    enabled -            true | false
# 3.    allowedScopeValues - ALL of the scopes that are available for the tenant. A subset of these are
#                            available to each of the clients
# 4.    allowUnlimitedRate - true | false. True will override any rate limit set in the rateLimits property

type Tenant {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!    
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    allowSocialLogin: Boolean!
    allowAnonymousUsers: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    federatedAuthenticationConstraint: String!
    federatedauthenticationconstraintid: String
    markForDelete: Boolean!
    tenantType: String!
    tenanttypeid: String
    migrateLegacyUsers: Boolean!
    allowLoginByPhoneNumber: Boolean!
    allowForgotPassword: Boolean!
    defaultRateLimit: Int
    defaultRateLimitPeriodMinutes: Int
}

type TenantSupportedClaimRel {
    tenantId: String!
    claim: String!
}

type TenantAnonymousUserConfiguration {
    tenantId: String!
    defaultcountrycode: String
    defaultlangugecode: String
    tokenttlseconds: Int!
}


# Does the tenant have certain users with email domains that can
# manage the tenant for themselves?
type TenantManagementDomainRel {
    tenantId: String!
    domain: String!
}

# Does the tenant have certain users who are allowed to login
# using this tenant?
type TenantRestrictedAuthenticationDomainRel {
    tenantId: String!
    domain: String!
}

# Either client secret should be defined or usePkce should be set to true
# if no client secret, then client auth type should be NONE
# refreshTokenAllowed - does the external provider allow for refresh tokens? default false 
#
# socialLoginIcon -> social login, in case the login screen wants to display a "Sign in with Google/Facebook/Twitter + <Google/Facebook/Twitter Icon>"
# socialLoginDisplayName -> social login, the name to display 
type FederatedOIDCProvider {
    federatedOIDCProviderId: String!
    federatedOIDCProviderName: String!
    federatedOIDCProviderDescription: String
    federatedOIDCProviderTenantId: String
    federatedOIDCProviderClientId: String!
    federatedOIDCProviderClientSecret: String
    federatedOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    scopes: [String!]!
    usePkce: Boolean!
    clientAuthType: String!
    clientauthtypeid: String
    federatedOIDCProviderType: String!
    federatedoidcprovidertypeid: String
    socialLoginProvider: String
    markForDelete: Boolean!
}

type FederatedOIDCProviderTenantRel {    
    federatedOIDCProviderId: String!
    tenantId: String!
}

type SocialOIDCProviderTenantRel {
    federatedOIDCProviderId: String!
    tenantId: String!
}

# domain is the primary key (unique) in this relationship.
type FederatedOIDCProviderDomainRel {
    federatedOIDCProviderId: String!
    domain: String!
}

## TODO
## Change this to TenantRegistrationConfig
## and add
## 1.   requireAccessTermsAndConditions    Boolean!
## 2.   termsAncConditionsUri              String
## 3.   requireCaptchaOnRegistration       Boolean!
## 4.   captchaConfig                      To be determined
type TenantPasswordConfig {
    tenantId: String!
    passwordMinLength: Int!
    passwordMaxLength: Int! 
    passwordHashingAlgorithm: String!
    requireUpperCase: Boolean!
	requireLowerCase: Boolean!
	requireNumbers: Boolean!
	requireSpecialCharacters: Boolean!
	specialCharactersAllowed: String
    requireMfa: Boolean!
    mfaTypesRequired: String
    allowMfa: Boolean!
    mfaTypesAllowed: String
    maxRepeatingCharacterLength: Int
    passwordRotationPeriodDays: Int
    passwordHistoryPeriod: Int
}


type TenantLegacyUserMigrationConfig {
    tenantId: String!
    authenticationUri: String!
    userProfileUri: String!
    usernameCheckUri: String!
}

# 1.    tenantId -      Parent tenant (write once, read only)
# 2.    clientId -      GUID
# 3.    clientSecret -  A 256-bit hex-encoded value
# 4.    clientName
# 5.    clientDescription
# 6.    enabled -       true | false
# 7.    redirectUris - List of redirect URIs for authorization
# 8.    oidcEnabled -  Allow SSO for this client
# 9.    pkceEnabled
# 10.   clientType
# 11.   userTokenTTLSeconds default is 60 minutes, configurable up to 12 hours
# 12.   allowUserSelfRegistration default false
# 13.   allowDelegatedAuthentication default false
type Client {
    tenantId: String!
    clientId: String!
    clientSecret: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean!
    oidcEnabled: Boolean!
    pkceEnabled: Boolean!
    clientType: String!
    clienttypeid: String
    userTokenTTLSeconds: Int
    clientTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
    markForDelete: Boolean!
}

type PortalUserProfile {
    userId: String!
    federatedOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    countryCode: String
    preferredLanguageCode: String
    twoFactorAuthType: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
    scope: [Scope!]!
    tenantId: String!
    tenantName: String!
    managementAccessTenantId: String
}

# 1.    domain is just the domain part of the email
type User {
    userId: String!
    federatedOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    addressLine1: String
    city: String
    postalCode: String
    stateRegionProvince: String
    countryCode: String
    preferredLanguageCode: String
    twoFactorAuthType: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
    markForDelete: Boolean!
}

type UserTenantRel {
    userId: String!
    tenantId: String!
    enabled: Boolean!
    relType: String!
}

type UserTenantRelView {
    userId: String!
    tenantId: String!
    tenantName: String!
    relType: String!
}

type AuthenticationGroup {
    tenantId: String!
    authenticationGroupId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
    defaultGroup: Boolean!
    markForDelete: Boolean!
}

type AuthenticationGroupClientRel {
    clientId: String!
    authenticationGroupId: String!
}

type AuthenticationGroupUserRel {
    authenticationGroupId: String!
    userId: String!
}

# default - for newly registered or created users within the tenant, assign to any group 
# in the tenant that is marked with default
type AuthorizationGroup {
    tenantId: String!
    groupId: String!
    groupName: String!
    groupDescription: String
    default: Boolean!
    allowForAnonymousUsers: Boolean!
    markForDelete: Boolean!
}

type AuthorizationGroupUserRel {
    userId: String!
    groupId: String!
}


type UserCredential {
    userId: String!
    salt: String!
    hashedPassword: String!
    hashingAlgorithm: String!
    dateCreated: String!    
}

type SigningKey {
    keyId: String!
    tenantId: String!    
    keyType: String!
    keyName: String!
    keyTypeId: String
    keyUse: String!
    privateKeyPkcs8: String!
    password: String
    certificate: String
    publicKey: String
    expiresAtMs: Float!
    status: String!
    statusId: String
    markForDelete: Boolean!
}

# Can optionally have a constraint definition tied to this scope.
# Not a requirement, but if one exists, then you MAY, if you choose,
# create an access rule that you can apply to the tenant (and so the 
# client and groups which belong to the tenant) which have this scope.

type Scope {
    scopeId: String!
    scopeName: String!
    scopeDescription: String!
    scopeUse: String!
    markForDelete: Boolean!
}

type ScopeAccessRuleSchema {
    scopeAccessRuleSchemaId: String!
    schemaVersion: Int!
    scopeId: String!
    scopeAccessRuleSchema: String!
}

type AccessRule {
    accessRuleId: String!
    accessRuleName: String!
    scopeAccessRuleSchemaId: String!
    accessRuleDefinition: String!
}

type RateLimitServiceGroup {
    servicegroupid: String!
    servicegroupname: String!
    servicegroupdescription: String
    markForDelete: Boolean!
}


type RateLimit {
    ratelimitid: String!
    ratelimitname: String!
    servicegroupid: String!
}

type TenantRateLimitRel {
    tenantId: String!
    servicegroupid: String!
    allowUnlimitedRate: Boolean
    rateLimit: Int
    rateLimitPeriodMinutes: Int
}

type TenantRateLimitRelView {
    tenantId: String!
    tenantName: String!
    servicegroupid: String!
    servicegroupname: String!
    allowUnlimitedRate: Boolean
    rateLimit: Int
    rateLimitPeriodMinutes: Int
}


# Access rules CAN be applied at the tenant level for any non-Root tenant
# Any client or group will automatically inherit these restrictions.
# Access rule order of precendence:
# 1. Defined on the user, inherits others from group membership, client and tenant
# 2. Defined on the group, inherits others from client and tenant
# 3. Defined on the client, inherits others from tenant
# 4. Defined on the tenant

type TenantAvailableScope {
    tenantId: String!
    scopeId: String!
    accessRuleId: String
}

type ClientScopeRel {
    tenantId: String!
    clientId: String!
    scopeId: String!
}


type AuthorizationGroupScopeRel {
    groupId: String!
    tenantId: String!
    scopeId: String!
}

type UserScopeRel {
    userId: String!
    tenantId: String!
    scopeId: String!
}

type PreAuthenticationState {
    token: String!
    state: String
    redirectUri: String!
    codeChallenge: String
    codeChallengeMethod: String
    responseMode: String!
    responseType: String!
    scope: String!
    tenantId: String!
    clientId: String!
    expiresAtMs: Float!
}

type AuthorizationCodeData {
    code: String!
    redirectUri: String!
    clientId: String!
    tenantId: String!
    scope: String!
    codeChallengeMethod: String
    codeChallenge: String
    userId: String!
    expiresAtMs: Float!
}

type SuccessfulLoginResponse {
    mfaEnabled: Boolean!
    userId: String!
    mfaType: String
    challenge: String
}

type RefreshData {
    refreshToken: String!
    tenantId: String!
    clientId: String!
    userId: String!
    redirecturi: String!
    refreshTokenClientType: String!
    refreshtokenclienttypeid: String
    refreshCount: Int!
    scope: String!
}

type FederatedOIDCAuthorizationRel {
    state: String!
    codeVerifier: String
    codechallengemethod: String
    federatedOIDCProviderId: String!
    initState: String!
    initRedirectUri: String!
    initTenantId: String!
    initClientId: String!
    initScope: String!
    initCodeChallengeMethod: String
    initCodeChallenge: String
    initResponseMode: String!
    initResponseType: String!
    expiresAtMs: Float!
    returnUri: String
}

type ClientAuthHistory {
    jti: String!
    clientId: String!
    tenantId: String!
    expiresAtSeconds: Float!
}

type Contact {
    contactid: String!
    objectid: String!
    objecttype: String!
    email: String!
    name: String
    userid: String
}

type ChangeEvent {
    changeEventId: String!
    objectid: String!
    objecttype: String!
    changeEventType: String!
    changeEventTypeId: String
    changeEventClass: String!
    changeEventClassId: String
    changeTimestamp: Float!
    changedById: String!
    data: String!
    signature: String!
	keyId: String!
}

type TenantLookAndFeel {
    tenantid: String!
    adminheaderbackgroundcolor: String
    adminheadertextcolor: String
    adminlogo: String
    adminheadertext: String
    authenticationheaderbackgroundcolor: String
    authenticationheadertextcolor: String
    authenticationlogo: String
    authenticationlogomimetype: String
    authenticationheadertext: String
    footerlinks: [FooterLink]
}

type FooterLink {
    footerlinkid: String!
    tenantid: String!
    linktext: String!
    uri: String!
}

type TenantMetaData {
    tenantLookAndFeel: TenantLookAndFeel
    tenant: Tenant!
}

type SchedulerLock {
    lockName: String!
    lockInstanceId: String!
    lockStartTimeMS: Float!
    lockExpiresAtMS: Float!
}

type UserFailedLoginAttempts {
    userId: String!
    failureAtMS: Float!
}

enum LoginUserNameHandlerAction {
    OIDC_REDIRECT
    ERROR
    ENTER_PASSWORD
}

type OIDCRedirectActionHandlerConfig {
    redirectUri: String!
    state: String!
    clientId: String!
    codeChallenge: String
    codeChallengeMethod: String
    scope: String
    responseType: String!
    responseMode: String!
}

type ErrorActionHandler {
    errorCode: String!
    errorMessage: String!
}

type LoginUserNameHandlerResponse {
    action: LoginUserNameHandlerAction!
    oidcRedirectActionHandlerConfig: OIDCRedirectActionHandlerConfig
    errorActionHandler: ErrorActionHandler
}

enum LoginAuthenticationHandlerAction {
    ERROR
    AUTHENTICATED
    SECOND_FACTOR_INPUT
}

enum SecondFactorType {
    EMAIL
    SMS
    TOTP
    SECURITY_KEY
}

type LoginAuthenticationSuccessConfig {
    code: String!
    redirectUri: String!
    responseMode: String
    state: String
}

type LoginAuthenticationHandlerResponse {
    status: LoginAuthenticationHandlerAction!
    secondFactorType: SecondFactorType
    successConfig: LoginAuthenticationSuccessConfig
    errorActionHandler: ErrorActionHandler
}

enum MarkForDeleteObjectType {
    TENANT
    CLIENT
    USER
    AUTHORIZATION_GROUP
    AUTHENTICATION_GROUP
    SCOPE
    FEDERATED_OIDC_PROVIDER
    RATE_LIMIT_SERVICE_GROUP
    SIGNING_KEY
}

type MarkForDelete {
    markForDeleteId: String!
    objectType: MarkForDeleteObjectType!
    objectId: String!
    submittedBy: String!
    submittedDate: Float!
    completedData: Float
}

type DeletionStatus {
    markForDeleteId: String!
    step: String!
    startedAt: Float!
    completedAt: Float
}


############################################################################
################ SEARCH TYPES AND RESPONSES FOR MUTATATIONS ################
############################################################################

enum SearchResultType {
    TENANT
    CLIENT
    USER
    AUTHORIZATION_GROUP
    AUTHENTICATION_GROUP
    ACCESS_CONTROL
    OIDC_PROVIDER
    RATE_LIMIT
    KEY
}

type ObjectSearchResultItem {
    objectid: String!    
    objecttype: SearchResultType!
    owningtenantid: String
    owningclientid: String
    name: String!
    description: String
    subtypekey: String
    subtype: String
    email: String
    enabled: Boolean    
}

type RelSearchResultItem {
    owningtenantid: String!
    owningtenantname: String
    parentid: String!
    parenttype: SearchResultType!
    parentname: String
    childid: String!
    childtype: SearchResultType!
    childname: String!
    childdescription: String
}


type ObjectSearchResults {
    starttime: Float!
    endtime: Float!
    took: Int!
    page: Int!
    perpage: Int!
    total: Int!
    resultlist: [ObjectSearchResultItem!]!
}

type RelSearchResults {
    starttime: Float!
    endtime: Float!
    took: Int!
    page: Int!
    perpage: Int!
    total: Int!
    resultlist: [RelSearchResultItem!]!
}

type LookaheadItem {
    id: String!
    matchingString: String
    displayValue: String!
}

type LookaheadResult {
    category: SearchResultType!
    resultList: [LookaheadItem!]!
}

enum SearchRelType {
    AUTHORIZATION_GROUP_USER_REL
    AUTHENTICATION_GROUP_USER_REL
    CLIENT_AUTHENTICATION_GROUP_REL
}
    

type UserMFARel {
    userId: String!
    mfaType: String!
    primaryMfa: Boolean!
    totpSecret: String
    totpHashAlgorithm: String
    fido2PublicKey: String
    fido2CredentialId: String
    fido2Algorithm: String
    fido2Transports: String
    fido2KeySupportsCounters: Boolean
}

type TOTPResponse {
    userMFARel: UserMFARel!
    uri: String!
}

############################################################################
################ INPUT TYPES AND RESPONSES FOR MUTATATIONS #################
############################################################################


enum SearchFilterInputObjectType {
    TENANT_ID
    CLIENT_ID
    USER_ID
    AUTHORIZATION_GROUP_ID
    AUTHENTICATION_GROUP_ID
}

input SearchFilterInput {
    objectType: SearchFilterInputObjectType!
    objectValue: String!
}


input SearchInput {
    term: String
    resultType: SearchResultType
    filters: [SearchFilterInput]
    page: Int!
    perPage: Int!
    sortField: String
    sortDirection: String
}

input RelSearchInput {
    term: String
    owningtenantid: String
    parenttype: SearchResultType
    parentid: String  
    childtype: SearchResultType
    childid: String
    childids: [String]
    page: Int!
    perPage: Int!
    sortField: String
    sortDirection: String
}

input FederatedOIDCProviderCreateInput {
    federatedOIDCProviderName: String!
    federatedOIDCProviderDescription: String
    federatedOIDCProviderTenantId: String
    federatedOIDCProviderClientId: String!
    federatedOIDCProviderClientSecret: String
    federatedOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    usePkce: Boolean!
    federatedOIDCProviderType: String!
    federatedoidcprovidertypeid: String
    clientAuthType: String!
    clientauthtypeid: String
    scopes: [String!]!
    socialLoginProvider: String
}

input FederatedOIDCProviderUpdateInput {
    federatedOIDCProviderId: String!
    federatedOIDCProviderName: String!
    federatedOIDCProviderDescription: String
    federatedOIDCProviderTenantId: String
    federatedOIDCProviderClientId: String!
    federatedOIDCProviderClientSecret: String
    federatedOIDCProviderWellKnownUri: String!
    refreshTokenAllowed: Boolean!
    usePkce: Boolean!
    federatedOIDCProviderType: String!
    federatedoidcprovidertypeid: String
    clientAuthType: String!
    clientauthtypeid: String
    scopes: [String!]!
    socialLoginProvider: String
}


input ContactCreateInput {
    objectid: String!
    objecttype: String!
    email: String!
    name: String
    userid: String
}


input PasswordConfigInput {
    tenantId: String!
    passwordMinLength: Int!
    passwordMaxLength: Int! 
    passwordHashingAlgorithm: String!
    requireUpperCase: Boolean!
	requireLowerCase: Boolean!
	requireNumbers: Boolean!
	requireSpecialCharacters: Boolean!
	specialCharactersAllowed: String
    requireMfa: Boolean!
    mfaTypesRequired: String
    allowMfa: Boolean!
    mfaTypesAllowed: String
    maxRepeatingCharacterLength: Int
    passwordRotationPeriodDays: Int
    passwordHistoryPeriod: Int
}

input TenantAnonymousUserConfigInput {
    tenantId: String!
    defaultcountrycode: String
    defaultlangugecode: String
    tokenttlseconds: Int!
}

input TenantCreateInput {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    allowAnonymousUsers: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    allowSocialLogin: Boolean!
    federatedAuthenticationConstraint: String!    
    tenantType: String!
    migrateLegacyUsers: Boolean!
    allowLoginByPhoneNumber: Boolean!
    allowForgotPassword: Boolean!
    defaultRateLimit: Int
    defaultRateLimitPeriodMinutes: Int
}

input TenantUpdateInput {
    tenantId: String!
    tenantName: String!
    tenantDescription: String
    enabled: Boolean!
    allowUnlimitedRate: Boolean!
    allowUserSelfRegistration: Boolean!
    allowAnonymousUsers: Boolean!
    verifyEmailOnSelfRegistration: Boolean!
    allowSocialLogin: Boolean!
    federatedAuthenticationConstraint: String!
    tenantType: String!
    migrateLegacyUsers: Boolean!
    allowLoginByPhoneNumber: Boolean!
    allowForgotPassword: Boolean!
    defaultRateLimit: Int
    defaultRateLimitPeriodMinutes: Int
}

input TenantLegacyUserMigrationConfigInput {
    tenantId: String!
    authenticationUri: String!
    userProfileUri: String!
    usernameCheckUri: String!
}

input FooterLinkInput {
    footerlinkid: String
    tenantid: String!
    linktext: String!
    uri: String!
}

input TenantLookAndFeelInput {
    tenantid: String!
    adminheaderbackgroundcolor: String
    adminheadertextcolor: String
    adminlogo: String
    adminheadertext: String
    authenticationheaderbackgroundcolor: String
    authenticationheadertextcolor: String
    authenticationlogo: String
    authenticationlogomimetype: String
    authenticationheadertext: String
    footerlinks: [FooterLinkInput]
}

input ClientCreateInput {
    tenantId: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean!
    oidcEnabled: Boolean!
    pkceEnabled: Boolean!
    clientType: String!
    clienttypeid: String
    userTokenTTLSeconds: Int
    clientTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
}

input ClientUpdateInput {
    tenantId: String!
    clientId: String!
    clientName: String!
    clientDescription: String
    enabled: Boolean!
    oidcEnabled: Boolean!
    pkceEnabled: Boolean!
    clientType: String!
    clienttypeid: String
    userTokenTTLSeconds: Int
    clientTokenTTLSeconds: Int
    maxRefreshTokenCount: Int
}

input SigningKeyCreateInput {
    tenantId: String!    
    keyType: String!
    keyTypeId: String
    keyName: String!
    keyUse: String!
    privateKeyPkcs8: String!
    password: String
    certificate: String
    publicKey: String
    expiresAtMs: Float
}

input SigningKeyUpdateInput {
    keyId: String!
    status: String!
    keyName: String
    keyUse: String
}


input RateLimitServiceGroupCreateInput {
    servicegroupname: String!
    servicegroupdescription: String
}

input RateLimitServiceGroupUpdateInput {
    servicegroupid: String!
    servicegroupname: String!
    servicegroupdescription: String
}

input ScopeCreateInput {
    scopeName: String!
    scopeDescription: String!
    scopeAccessRuleSchemaId: String
}

input ScopeUpdateInput {
    scopeId: String!
    scopeName: String!
    scopeDescription: String!
    scopeAccessRuleSchemaId: String
}

input AuthenticationGroupCreateInput {
    tenantId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
    defaultGroup: Boolean!
}

input AuthenticationGroupUpdateInput {
    tenantId: String!
    authenticationGroupId: String!
    authenticationGroupName: String!
    authenticationGroupDescription: String
    defaultGroup: Boolean!
}

input AuthorizationGroupCreateInput {
    tenantId: String!
    groupName: String!
    groupDescription: String
    default: Boolean!
    allowForAnonymousUsers: Boolean!
}

input AuthorizationGroupUpdateInput {
    tenantId: String!
    groupId: String!
    groupName: String!
    groupDescription: String
    default: Boolean!
    allowForAnonymousUsers: Boolean!
}

## Scope constraint schemas
input ScopeAccessRuleSchemaCreateInput {
    scopeId: String!
    schema: String!
}

input ScopeAccessRuleSchemaUpdateInput {
    scopeAccessRuleSchemaId: String!
    scopeId: String!
    schema: String!
}

## Access rules
input AccessRuleCreateInput {
    accessRuleName: String!
    scopeAccessRuleSchemaId: String!
    accessRuleDefinition: String!
}

input AccessRuleUpdateInput {
    accessRuleId: String!
    accessRuleName: String!
    scopeAccessRuleSchemaId: String!
    accessRuleDefinition: String!
}

input LoginFailurePolicyInput {
    tenantId: String!
    loginFailurePolicyType: String!
    loginfailurepolicytypeid: String
    failureThreshold: Int!
    pauseDurationMinutes: Int
    numberOfPauseCyclesBeforeLocking: Int
    initBackoffDurationMinutes: Int
    numberOfBackoffCyclesBeforeLocking: Int
}

input UserCreateInput {
    federatedOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    addressLine1: String
    city: String
    postalCode: String
    stateRegionProvince: String
    countryCode: String
    preferredLanguageCode: String
    twoFactorAuthType: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
}

input UserUpdateInput {
    userId: String!
    federatedOIDCProviderSubjectId: String
    email: String!
    emailVerified: Boolean!
    domain: String!
    firstName: String!
    lastName: String!
    middleName: String
    phoneNumber: String
    address: String
    addressLine1: String
    city: String
    postalCode: String
    stateRegionProvince: String
    countryCode: String
    preferredLanguageCode: String
    twoFactorAuthType: String
    locked: Boolean!
    enabled: Boolean!
    nameOrder: String!
}

input MarkForDeleteInput {
    markForDeleteObjectType: MarkForDeleteObjectType!
    objectId: String!
}
